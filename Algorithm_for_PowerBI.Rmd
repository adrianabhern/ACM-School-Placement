```{r pressure, echo=FALSE}
# 'dataset' holds the input data for this script

root_dir = "C:\\Users\\CLuedtke\\ACM-School-Placement\\"

library(gmapsdistance)
library(readxl)
library(dplyr)
library(tidyr)
library(data.table)
library(dummies)
library(doSNOW)

acm_df <- read.csv(file = paste(root_dir, "survey_export.csv", sep = ""))
acm_commutes <- read_excel(path = paste(root_dir, "Input 2 - ACM Commutes.xlsx", sep = ""))
school_df <- read_excel(path = paste(root_dir, "Input 3 - School Data.xls", sep = ""))

# Add id columns
acm_commutes$acm_id <- 1:nrow(acm_commutes)
school_df$sch_id <- 1:nrow(school_df)

acm_commutes_long <-
  select(acm_commutes, -or) %>%
  gather(dest, dist, -acm_id) %>%
  mutate(id_dest = paste(acm_id, dest, sep = "_"))

# This function takes the input acm_df and encodes the variables in a way that makes the mathematically tractable.
encode_acm_df <- function(df){
  
  df <- acm_df
  acm_enc <- select(df, acm_id)
  
  # Ed Attainment
  acm_enc$Ed_HS <- as.numeric(grepl("High School/GED", df$Educational.Attainment))
  acm_enc$Ed_SomeCol <- grepl("Some College", df$Educational.Attainment) + grepl("Associate's Degree", df$Educational.Attainment)
  acm_enc$Ed_Col <- grepl("Bachelor's Degree", df$Educational.Attainment) + grepl("Master's Degree", df$Educational.Attainment)
  
  # Tutoring Experience
  acm_enc$HasTutored <- ifelse(df$Tutoring.Experience == "Yes", 1, 0)
  
  # Tutoring Preference
  acm_enc$Pref_HS <- ifelse(df$Grade.Lvl.Pref.HS == "High School", 1, 0)
  acm_enc$Pref_MS <- ifelse(df$Grade.Lvl.Pref.MS == "Middle School", 1, 0)
  acm_enc$Pref_ES <- ifelse(df$Grade.Lvl.Pref.ES == "Elementary School", 1, 0)
  
  # Math Proficiency
  acm_enc$Math_Confidence <- ifelse(df$Math.Confidence == "Pre-Algebra or lower" | df$Math.Confidence == "Algebra I", 0, 1)
  
  # Language Ability
  acm_enc$SpanishAble <- ifelse(df$Language.Ability.Spanish == "Spanish", 1, 0)
  acm_enc$SpanishAble[is.na(acm_enc$SpanishAble)] <- 0
  acm_enc$Lang_Other <- ifelse((df$Language.Other.English == "Yes") & (is.na(df$Language.Ability.Spanish != "Spanish")), 1, 0)
  
  # Add in other features
  acm_enc <- acm_enc %>%
               left_join(., select(acm_df,
                                   acm_id,
                                   Gender, 
                                   Manual.Placement, 
                                   Birth.Date,
                                   Race.Ethnicity.African.American.Black:Race.Ethnicity.Other), 
                         by=c("acm_id" = "acm_id")) %>%
               replace_na(list(Pref_HS = 0, Pref_MS = 0, Pref_ES = 0,
                               Lang_Other = 0)) %>%
               mutate(days_old = as.integer(Sys.Date() - as.Date(as.character(df$Birth.Date), format="%Y-%m-%d")))

  
  # Return
  acm_enc
}

acm_enc <- encode_acm_df(acm_df)

school_targets <- school_config(school_df, acm_enc)

# School configuration data frame. I think we could probably reduce the school configuration file to just the following elements: school name, team size, address, and local ethnic demographics.  From those data points alone and the corps demographic data, we should be able to calculate everything else.  

# This function calculates some import counts which I'm going to use a lot when trying to figure out the expected number of ACMs per team per metric.  This function will just be used internally by the school_config function.
corps_demographic_targets <- function(school_df, acm_enc){
  # Calculate some totals used later in the function
  N <- nrow(acm_enc)
  S <- nrow(school_df)
  
  # Counts of schools by level
  school_counts <- group_by(school_df, `School Type`) %>% summarise(count=n())
  
  # Approximation of densly spanish speaking schools
  dense_hispanic <- nrow(school_df[school_df$`% Hispanic` > 10, ])
  
  # We'll store our results in a list so we can return multiple tables
  distros <- list()
  
  # Produce ratio of folks who have completed at least an associates, and those who haven't
  distros$education <- data.frame(level = c("HS", "SomeCol"), ratio = c(nrow(acm_enc[acm_enc$Ed_HS == 1,]) / N, nrow(acm_enc[acm_enc$Ed_SomeCol == 1,]) / N))
  
  # Identify rates of Tutoring Experience
  distros$tut_exp <- group_by(acm_enc, HasTutored) %>% 
    summarise(count=n()) %>% 
    mutate(ratio = count/N)
  
  # Spanish and other spoken language distribution
  distros$lang <- data.frame(ability = c("other"), ratio = c(nrow(acm_enc[acm_enc$Lang_Other == 1, ]) / N))
  
  # Math Ability
  distros$math <- nrow(acm_enc[acm_enc$Math_Confidence == 1,]) / N
  
  # Note on tutoring pref.  We'll simply set this parameter to the team size appropriate for the level type.  This should thus maximize the incentive on putting folks with the appropriate tutoring pref at the appropriate levels.
  distros
}

# I derived this function mildly arbitrarily. The logic is that we probably want at least one spanish speaker at a school, but there are then diminishing returns.  It scales so that for a school that 100% hispanic, we would aim to have 5 spanish speakers on the team.  A team thats 50% hispanic will aim to have 4. The main problem with this approach is that we may create too many spots for spanish speakers, or have not have enough spanish speakers for the intended spots.  
spanishNeed <- function(x) {
  1.5772*log(x) - 2.1205
}

# Directly calculates the expected number of ACMs per team for each of the markers.
# My methodology is to aim for a uniform distribution when it makes sense.
school_config <- function(school_df, acm_enc){
  # Precalculate some helpful counts
  corps_demos <- corps_demographic_targets(school_df, acm_enc)
  # Unravel list into some variables.  Mostly so that the code is a little cleaner later.
  education <- corps_demos$education
  lang <- corps_demos$lang
  tut_exp <- corps_demos$tut_exp
  math <- corps_demos$math
  
  
  
  school.data <- select(school_df, `sch_id`, `Team Size`, `School Type`, `% Caucasian`:`% N/A`) %>%
    rename(size = `Team Size`,
           span = `School Type`) %>%
    mutate(HSGrad_tgt = ifelse(span=="HS", 0, education[education$level %in% 'HS',]$ratio * size),
           SomeCol_tgt = education[education$level %in% 'SomeCol',]$ratio * size,
           SpanPref_ES = ifelse(span=="ES", size, 0),
           SpanPref_MS = ifelse(span=="MS", size, 0),
           SpanPref_HS = ifelse(span=="HS", size, 0),
           TutExp = size * tut_exp[tut_exp$HasTutored == 1,]$ratio,
           SpanishNeed = pmax(spanishNeed(`% Hispanic`), 1),# This sets a minimum of 1 spanish speaker per team.  This might make sense in LA, but not other places.
           OtherLang_tgt = lang[lang$ability %in% 'other',]$ratio * size,
           Math_tgt = ifelse(span=="ES", size*.5*math, ifelse(span=="MS", .75*size*math, size*math))) 
}

initial_placement <- function(acm_enc, school_targets){
  # First place acm's at schools designated by Manual.Placement column
  # NOTE: Removed seed parameter.  Seed is used for reproducability, but we want randomness in the start.
  
  # first create an empty list
  team_placements = list()
  
  # use a for-loop to read each team size
  for (x in 1:nrow(school_targets)){
    team_slots = list(
      # create a list that repeats each school 'id' for the size of each team
      rep(x, 
          subset(school_targets$size, school_targets$sch_id == x)
          )
      )
    team_placements <- c(team_placements, team_slots)
  }
  
  team_placements <- data.frame(placement=unlist(team_placements))
  
  # Randomize Starting Place
  #set.seed(seed)
  
  team_placements_df <- data.frame(placement=team_placements[sample(nrow(team_placements), replace=F), ],
                                   acm_id= 1:nrow(team_placements))
  
  
  # Merge team_placements_df with acm_df on the 'id' column
  team_placements_df <- merge(acm_enc, team_placements_df, by = "acm_id", all.x = TRUE)
  
  # Honor Manual Placements
  sch_id_names <- school_df[, c("sch_id", "School Name")]
  colnames(sch_id_names) <- c("Manual.Placement_id", "School.Name")
  team_placements_df <- merge(team_placements_df, sch_id_names, by.x = "Manual.Placement", by.y = "School.Name", all.x = TRUE)
  acms_with_Manual.Placement <- subset(team_placements_df, (!is.na(team_placements_df$Manual.Placement)))
  acms_no_Manual.Placement <- subset(team_placements_df, (is.na(team_placements_df$Manual.Placement)))
  
  for (x in acms_with_Manual.Placement$acm_id){
    team_placements_df <- team_placements_df[order(team_placements_df$acm_id), ]
    rownames(team_placements_df) <- 1:nrow(team_placements_df)
    acm_row <- subset(acms_with_Manual.Placement, acms_with_Manual.Placement$acm_id == x)
    
    # Choose 1 acm_id currently assigned to the school at which we want to ensure manual placement is honored
    acm_id_to_swap <- sample( subset( acms_no_Manual.Placement$acm_id, acms_no_Manual.Placement$placement == acm_row$Manual.Placement_id ), 1 )
    
    # Swap the team assignment of those 2 ACMs
    swap1 <- acm_row$acm_id
    swap2 <- acm_id_to_swap
    team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
    
  }
  
  # We would like to ensure that high school students get placed in ES or MS
  acms_for_swaps <- merge(team_placements_df[is.na(team_placements_df$Manual.Placement_id), ], school_targets, by.x = "placement", by.y = "sch_id", all.x = TRUE)
  
  #print(acms_for_swaps)
    
  hs_acms_to_swap <- acms_for_swaps[(acms_for_swaps$Ed_HS == 1) & (acms_for_swaps$span == "HS"),]
  acms_to_swap_with <- acms_for_swaps[(acms_for_swaps$Ed_HS == 0) & (acms_for_swaps$span != "HS"),]
  acms_to_swap_with <- acms_to_swap_with[sample(nrow(acms_to_swap_with), nrow(hs_acms_to_swap), replace=F), ]
  
  team_placements_df[team_placements_df$acm_id %in% hs_acms_to_swap$acm_id, ]$placement = acms_to_swap_with$placement
  team_placements_df[team_placements_df$acm_id %in% acms_to_swap_with$acm_id, ]$placement = hs_acms_to_swap$placement
 
  return(team_placements_df)
    
}

team_placements_df = initial_placement(acm_enc, school_targets)

hs_loss <- function(targets, actuals){
  loss <- ifelse(targets == 0, (targets - actuals) * -1e10, (targets - actuals)^2)
  sum(loss)
}


calculate_score = function(team_placements_df, school_targets, gender_target=gender_g) {
  
  # Merge  with school_df to pull in school characteristics
  team_placements_df <- merge(team_placements_df, school_targets, by.x = "placement", by.y = "sch_id", all.x = TRUE)
  
  # Store each score in a list
  scores = list()
  
  #################
  # COMMUTE SCORE #
  #################
  
  # This score is simply the sum number of seconds each ACM travels to their assigned school
  
  team_placements_df$dest = colnames(acm_commutes)[team_placements_df$placement + 1]
  
  team_placements_df <- within(team_placements_df, id_dest <- paste(acm_id, dest, sep = "_"))
  
  dt_commutes <- data.table(acm_commutes_long)
  
  # Take the sqrt to scale the value closer to the other features
  scores$commute_score <- sqrt(dt_commutes[id_dest %in% team_placements_df$id_dest,  sum(dist)])
  
  ################
  # GENDER SCORE #
  ################

  # This score measures the average of differences between each gender's percent occurrence across the corps and its percent occurrence on each team
  
  # Create data.frame with each potential combination of gender and school, based on the survey responses provided
  
  
  gender_frame <- 
    expand.grid(placement = 1:nrow(school_targets), Gender = levels(team_placements_df$Gender))
  
  # Precalculate tibbl containing percentage representation of each gender category across the entire corps
  # Can we move this to school targets?  Try to calculate static things once.
  gender_g <- group_by(acm_df, Gender) %>% summarize(pct_g = n()/nrow(acm_df))

  
  # Merge previous two frames by "gender"
  gender_frame_g <-
    merge(x = gender_frame,
          y = gender_g,
          by = "Gender",
          all.x = TRUE)
  
  # Represent percentage of each gender category within each team
  gender_gs <- 
    team_placements_df %>%
    group_by(placement, Gender) %>%
    dplyr::summarize(n_gs = n()) %>%
    group_by(placement) %>%
    dplyr::mutate(pct_gs = n_gs/sum(n_gs))
  
  # Calculate absolute value of difference between gender percentages at each team and across the corps
  gender_frame_gs <-
    merge(x = gender_frame_g,
          y = gender_gs,
          by = c("placement", "Gender"),
          all.x = TRUE) %>%
    within({
      diff_gs <- pct_g - ifelse(is.na(pct_gs), 0, pct_gs)
      abs_diff_gs <- abs(diff_gs)
    }) %>%
    summarise(mean_gend_diff = mean(abs_diff_gs))
  
  scores$gender_score <- gender_frame_gs$mean_gend_diff * 5000
  
  #############
  # AGE SCORE #
  #############
  
  # This score is the difference between the [overall age variance across the corps] and [overall average of each team's average age variance]
  
  # Moved computation of age for each acm to acm_enc so that we only do it once.
  #team_placements_df$days_old <- as.integer(Sys.Date() - as.Date(as.character(team_placements_df$Birth.Date), format="%Y-%m-%d"))

  age_var <-
    group_by(team_placements_df, placement) %>%
    summarize(age_var = var(days_old)) %>%
    ungroup() %>%
    summarize(avg_age_var = mean(age_var))

  scores$age_score <- abs(age_var$avg_age_var - var(team_placements_df$days_old)) /10
  
  ###################
  # ETHNICITY SCORE #
  ###################
  
  # This score is the overall average of each team's average % representation that each teammate experiences. For example, 0.44 means that for the average team, the average teammate experiences that his/her personal ethnicity is represented in 44% of the team.
  
  ethnicity_eths <- 
    team_placements_df %>%
    group_by(placement, 
             Race.Ethnicity.African.American.Black, 
             Race.Ethnicity.White.Caucasian, 
             Race.Ethnicity.Asian,
             Race.Ethnicity.Hispanic.Latino,
             Race.Ethnicity.Middle.Eastern,
             Race.Ethnicity.Native.Hawaiian.Pacific.Islander,
             Race.Ethnicity.American.Indian.Alaskan.Native,
             Race.Ethnicity.Other) %>%
    dplyr::summarize(n_eths = n()) %>%
    group_by(placement) %>%
    dplyr::mutate(pct_eths = n_eths/sum(n_eths) * n_eths / sum(n_eths)) %>%
    dplyr::mutate(avg_eths_rep = sum(pct_eths)) %>%
    summarize(avg_eths_rep = mean(avg_eths_rep)) %>%
    summarize(avg_eths_rep = mean(avg_eths_rep))

  scores$ethnicity_score <- ethnicity_eths$avg_eths_rep * 1000
  
  #################
  #    Scoring    #
  #################  
  
  placed <- team_placements_df %>% 
                filter(is.na(team_placements_df$Manual.Placement)) %>%
                group_by(placement) %>%
                summarise(HS_Grads = sum(Ed_HS),
                          SomeCol = sum(Ed_SomeCol),
                          Tutoring = sum(HasTutored),
                          Spanish = sum(SpanishAble),
                          OtherLang = sum(Lang_Other),
                          Pref_HS = sum(Pref_HS),
                          Pref_MS = sum(Pref_MS),
                          Pref_ES = sum(Pref_ES),
                          MathAble = sum(Math_Confidence)) %>%
                left_join(., school_targets, by=c("placement" = "sch_id"))
  
  scores$HS_score <- hs_loss(placed$HSGrad_tgt, placed$HS_Grads) * 10 
  scores$SomeCol <- sum(abs(placed$SomeCol_tgt - placed$SomeCol)) * 10
  scores$Tutoring <- sum(abs(placed$TutExp - placed$Tutoring)) * 10
  scores$Spanish <- sum(abs(placed$SpanishNeed - placed$Spanish)) * 10
  scores$OtherLang <- sum(abs(placed$OtherLang_tgt - placed$OtherLang)) * 10
  scores$Grade_Pref <- sum(abs(placed$SpanPref_ES - placed$Pref_ES) + abs(placed$SpanPref_MS - placed$Pref_MS) + abs(placed$SpanPref_HS - placed$Pref_HS))
  scores$Math <- sum(abs(placed$Math_tgt - placed$MathAble)) * 10         

  #################
  # OVERALL SCORE #
  #################
  
  scores$aggr_score <- sum(unlist(scores))
  
  return(scores)
}

current_temperature = function(iter, s_curve_amplitude, s_curve_center, s_curve_width) {
  s_curve_amplitude * s_curve(iter, s_curve_center, s_curve_width)
}

s_curve = function(x, center, width) {
  1 / (1 + exp((x - center) / width))
}

run_intermediate_annealing_process = function(starting_placements, school_df, best_placements, best_score, starting_iteration, number_of_iterations, s_curve_amplitude, s_curve_center, s_curve_width) {
  
  # starting_placements = team_placements_df 
  # school_df = school_targets
  # best_placements = team_placements_df 
  # best_score = 142078800000
  # starting_iteration = 1
  # number_of_iterations = 10000
  # s_curve_amplitude = 4000
  # s_curve_center = 0
  # s_curve_width = 3000
  # 
  team_placements_df <- starting_placements
  
  placement_score <- calculate_score(starting_placements, school_df)$aggr_score
  trace <- data.frame(iter=c(1:number_of_iterations + 1), score=0)
  trace[1, 2] <- placement_score

  for(i in 1:number_of_iterations) {
    iter = starting_iteration + i
    temp = current_temperature(iter, s_curve_amplitude, s_curve_center, s_curve_width)
    
    # Nick Question: Necessary to reset acm_id sort and index?
    # Create a copy of team_placements_df, which is Sorted by acm_id so that each row index will equal acm_id
    candidate_placements_df <- team_placements_df[order(team_placements_df$acm_id), ]
    rownames(candidate_placements_df) <- 1:nrow(candidate_placements_df)
    
    acms_no_Manual.Placement <- subset(candidate_placements_df, (is.na(candidate_placements_df$Manual.Placement)))

    # Choose 2 schools at random
    schools_to_swap = sample(1:nrow(school_df), 2)

    # Choose 1 ACM from each of those schools. Select only ACMs who have no Manual.Placement
    swap1 = sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == schools_to_swap[1] ], 1)
    swap2 = sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == schools_to_swap[2] ], 1)

    # Swap the team assignment of those 2 ACMs - NOTE this is done by index, but we use acm_id as index
    candidate_placements_df$placement = replace(candidate_placements_df$placement, c(swap1, swap2), candidate_placements_df$placement[c(swap2, swap1)])
    
    # Place firm restrictions here?
    #IsValid(candidate_placements_df)
    
    candidate_score = calculate_score(candidate_placements_df, school_df)
    trace[i+1, 2] <- candidate_score$aggr_score
    
    if (temp > 0) {
      ratio = exp((placement_score - candidate_score$aggr_score) / temp)
    } else {
      ratio = as.numeric(candidate_score$aggr_score < placement_score)
    }
    
    if (runif(1) < ratio) {
      team_placements_df = candidate_placements_df
      placement_score = candidate_score$aggr_score
      all_scores = candidate_score
      
      if (placement_score < best_score) {
        best_placements = team_placements_df
        best_score = placement_score
        best_score_diff = all_scores
      }
    }
  }
  
  # Merge in School characteristics
  best_placements <- merge(best_placements, school_df, by.x = "placement", by.y = "sch_id", all.x = TRUE)
  
  best_placements <- best_placements[order(best_placements$placement),]
  
  return(list(best_placements=best_placements, 
              best_score=best_score,
              diff_scores=best_score_diff,
              trace=trace))
}

output <- run_intermediate_annealing_process(starting_placements = team_placements_df, school_df = school_targets, best_placements = team_placements_df, best_score = 142078800000, starting_iteration = 1, number_of_iterations = 10000, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)

```