```{r Power BI Step 1 Rename Headers, echo=FALSE}
#library(readxl)
# This portion looks different in Power BI

# root_dir = "C:\\Users\\aperusse\\GitHub\\ACM-School-Placement\\"

# In Power BI the source is "survey_export.csv" because that's a more accurate representation of a real survey implementation with messy headers and all. "Input 1 - ACM Data.csv" holds the same data, but with clean headers.

# acm_df <- read_excel(path = paste(root_dir, "Input 1 - LA ACM Data.xlsx", sep = ""), col_types = c("text", "text", "text", "text","text","text","date", "numeric", "text","text","numeric", "text","text","text"))
# 
# # This part not necessary in PowerBI, since dates are read in as %m/%d/%Y already
# acm_df$Birth.Date <- format(as.Date(acm_df$Birth.Date), "%m/%d/%Y")
# 
# # This line mimics Power BI's behavior
# dataset <- acm_df


# How this portion appears in Power BI:

# 'dataset' holds the input data for this script
# 
# acm_df <- dataset
# 
# vars_df <- data.frame(
#   PowerBI.Survey.Items = c(
#     "Date Submitted",
#     "City",
#     "State/Region",
#     "Full name:",
#     "If applicable, preferred name(s):Â ",
#     "What is your date of birth?",
#     "City Year Site:What site will you serve with, and did you attend a City Year school at that site? (choose from # the list of schools)",
#     "School:What site will you serve with, and did you attend a City Year school at that site? (choose from the list # of schools)",
#     "What gender do you identify with?",
#     "African American/Black:What is your race/ethnicity (choose all that apply)",
#     "American Indian/Alaskan Native:What is your race/ethnicity (choose all that apply)",
#     "Asian:What is your race/ethnicity (choose all that apply)",
#     "Hispanic/Latino:What is your race/ethnicity (choose all that apply)",
#     "Middle Eastern:What is your race/ethnicity (choose all that apply)",
#     "Native Hawaiian or Pacific Islander:What is your race/ethnicity (choose all that apply)",
#     "White/Caucasian:What is your race/ethnicity (choose all that apply)",
#     "Other - Write In:What is your race/ethnicity (choose all that apply)",
#     "What is the highest level of education you have achieved?",
#     "Other - Write In:What is the highest level of education you have achieved?",
#     "Are you able to tutor and mentor students while speaking a language other than English?",
#     "Arabic:Other language",
#     "Cape Verdean Creole :Other language",
#     "Chinese (Cantonese):Other language",
#     "Chinese (Mandarin):Other language",
#     "Haitian Creole:Other language",
#     "French:Other language",
#     "Nepali:Other language",
#     "Polish:Other language",
#     "Spanish:Other language",
#     "Swahili:Other language",
#     "Urdu:Other language",
#     "Vietnamese:Other language",
#     "Other - Write In (Required):Other language",
#     "Do you have teaching or tutoring experience?",
#     "Months Teaching",
#     "Elementary school (K-5):What grade level(s) have you worked with in the past? Please select all that apply.",
#     "Middle school (6-8):What grade level(s) have you worked with in the past? Please select all that apply.",
#     "High school (9-12):What grade level(s) have you worked with in the past? Please select all that apply.",
#     "Do you have a teaching credential?",
#     "Elementary school:Which grade levels would you prefer to work with?",
#     "Middle school:Which grade levels would you prefer to work with?",
#     "High school:Which grade levels would you prefer to work with?",
#     "Would you prefer to support with ELA/literacy or math?",
#     "Please indicate the highest level of math in which you are confident in your skills.",
#     "Do you know where you will be living during the 2017-2018 school year?",
#     "Street address Line 1:SYAddress",
#     "Street address line 2:SYAddress",
#     "City:SYAddress",
#     "State:SYAddress",
#     "Zip:SYAddress",
#     "Will you be living with other City Year AmeriCorps members during the school year?:SYAddress",
#     "If so, please list their first and last names here::SYAddress",
#     "How will you travel to your school site?"
#   ),
#   Variable.Name = c(
#     "Date.Submitted",
#     "City",
#     "State.Region",
#     "Full.Name",
#     "Pref.Name",
#     "Birth.Date",
#     "Site.Name",
#     "Attnd.CY.School",
#     "Gender",
#     "Race.Ethnicity.African.American.Black",
#     "Race.Ethnicity.American.Indian.Alaskan.Native",
#     "Race.Ethnicity.Asian",
#     "Race.Ethnicity.Hispanic.Latino",
#     "Race.Ethnicity.Middle.Eastern",
#     "Race.Ethnicity.Native.Hawaiian.Pacific.Islander",
#     "Race.Ethnicity.White.Caucasian",
#     "Race.Ethnicity.Other",
#     "Educational.Attainment",
#     "Educational.Attainment.WriteIn",
#     "Language.Other.English",
#     "Language.Ability.Arabic",
#     "Language.Ability.CapeVerdeanCreole",
#     "Language.Ability.Chinese.Cantonese",
#     "Language.Ability.Chinese.Mandarin",
#     "Language.Ability.HaitianCreole",
#     "Language.Ability.French",
#     "Language.Ability.Nepali",
#     "Language.Ability.Polish",
#     "Language.Ability.Spanish",
#     "Language.Ability.Swahili",
#     "Language.Ability.Urdu",
#     "Language.Ability.Vietnamese",
#     "Language.Ability.Other",
#     "Tutoring.Experience",
#     "Tutoring.Experience.Months",
#     "Tutoring.Experience.ES",
#     "Tutoring.Experience.MS",
#     "Tutoring.Experience.HS",
#     "Teaching.Credential",
#     "Grade.Lvl.Pref.ES",
#     "Grade.Lvl.Pref.MS",
#     "Grade.Lvl.Pref.HS",
#     "Tutoring.Preference",
#     "Math.Confidence",
#     "Know.Living",
#     "Res.Address.Line.1",
#     "Res.Address.Line.2",
#     "Res.City",
#     "Res.State",
#     "Res.Postal.Code",
#     "Roomates",
#     "Roommate.Names",
#     "Travel.Method"
#   ), 
#   stringsAsFactors=FALSE
#   )
# 
# for (x in names(acm_df)){
#   try(names(acm_df)[names(acm_df) == x] <- vars_df$`Variable.Name`[vars_df$`PowerBI.Survey.Items` == x])
# }
```

```{r Power BI Step 2 Encode Variables, echo=FALSE}

#  Encode Variables & Clean Up Input Dataframes

#Before being able to calculate a score, we'll need to encode all of our variables numerically.  For categorical ## variables, we can create a dummy variable for all except one of the categories (this is because the last category can be inferred).

# This function takes the input acm_df and encodes the variables in a way that makes the mathematically tractable.

# library(dplyr)
# library(tidyr)
# 
# acm_df <- dataset

encode_acm_df <- function(df){

  df <- acm_df
  acm_enc <- select(acm_df, acm_id, Math.Confidence)
  
  # Ed Attainment
  acm_enc$Ed_HS <- as.numeric(grepl("High School", df$Educational.Attainment))
  acm_enc$Ed_SomeCol <- grepl("Some College", df$Educational.Attainment) + grepl("Associates Degree", df$Educational.Attainment)
  acm_enc$Ed_Col <- grepl("Bachelors Degree", df$Educational.Attainment) + grepl("Master's Degree", df$Educational.Attainment)
  
  # Tutoring Experience
  acm_enc$HasTutored <- as.numeric(grepl("Yes", df$Tutoring.Experience))
  
  # Language Ability
  acm_enc$SpanishAble <- as.numeric(grepl("Spanish", df$Language.Ability))
  acm_enc$Lang_Other <- ifelse(grepl("Spanish", df$Language.Ability) == F & grepl("Yes", df$Language.Ability), 1, 0)
  
  # Gender
  acm_enc$Male <- as.numeric(grepl("Male", df$Gender))
  acm_enc$Other.Gender <- as.numeric(grepl("Other", df$Gender))
  
  # Ethnicity
  acm_enc$Race.Ethnicity.Hispanic <- as.numeric(grepl("Hispanic/Latino", df$Race.Ethnicity))
  acm_enc$Race.Ethnicity.Asian <- as.numeric(grepl("Asian/Asian-American", df$Race.Ethnicity))
  acm_enc$Race.Ethnicity.White <- as.numeric(grepl("Caucasian/White", df$Race.Ethnicity))
  acm_enc$Race.Ethnicity.Black <- as.numeric(grepl("African-American/Black", df$Race.Ethnicity))
  
  # Add in other features
  acm_enc <- acm_enc %>%
               left_join(., select(df,
                                   acm_id,
                                   Manual.Placement, 
                                   Birth.Date), 
                         by=c("acm_id" = "acm_id")) %>%
               mutate(days_old = as.integer(Sys.Date() - as.Date(as.character(df$Birth.Date), format="%m/%d/%Y"))) %>%
               replace_na(list(Lang_Other = 0, days_old = 0))
  
  # Return
  acm_enc
}

# acm_enc <- encode_acm_df(acm_df)
# 
# dataset <- acm_enc

```

```{r Power BI Step 3 Simulated Annealing, echo=FALSE}
# 'dataset' holds the input data for this script
# changed days_old calculation to expect format="%m/%d/%Y"

# root_dir = "C:\\Users\\aperusse\\GitHub\\ACM-School-Placement\\"
# 
# #library(gmapsdistance)
# library(readxl)
# library(dplyr)
# library(tidyr)
# #library(doSNOW)
# # Loading this gave errors in Power BI
# #library(doParallel)
# 
# acm_enc <- dataset
# school_df <- read_excel(path = paste(root_dir, "Input 3 - LA School Data.xlsx", sep = ""))
# acm_commutes <- read_excel(path = paste(root_dir, "Input 2 - LA ACM Commutes.xlsm", sep = ""),
#                            col_names = c("acm_id", "ACM", "From", "dest", "To", "dist", "time", "min", "blank"),
#                            col_types = c("numeric", "text", "text", "text", "text", "numeric", "date", "numeric", "skip"), skip=1) %>%
#                 left_join(., school_df, by = c("dest" = "School")) %>%
#                 mutate(acm_dest_id = paste(acm_id, "-", sch_id))



# This function calculates some import counts which I'm going to use a lot when trying to figure out the expected number of ACMs per team per metric.  This function will just be used internally by the school_config function.
corps_demographic_targets <- function(school_df, acm_enc){
  # Calculate some totals used later in the function
  N <- nrow(acm_enc)
  S <- nrow(school_df)
  
  # Counts of schools by level
  school_counts <- group_by(school_df, GradeLevel) %>% summarise(count=n())
  
  # Approximation of densly spanish speaking schools
  dense_hispanic <- nrow(school_df[school_df$`% Hispanic` > 10, ])
  
  # We'll store our results in a list so we can return multiple tables
  distros <- list()
  
  # Produce ratio of folks who have completed at least an associates, and those who haven't
  distros$education <- data.frame(level = c("HS", "SomeCol"), ratio = c(nrow(acm_enc[acm_enc$Ed_HS == 1,]) / N, nrow(acm_enc[acm_enc$Ed_SomeCol == 1,]) / N))
  
  # Identify rates of Tutoring Experience
  distros$tut_exp <- group_by(acm_enc, HasTutored) %>% 
    summarise(count=n()) %>% 
    mutate(ratio = count/N)
  
  # Spanish and other spoken language distribution
  distros$lang <- data.frame(ability = c("spanish","other"), ratio = c(nrow(acm_enc[acm_enc$SpanishAble == 1, ]) / N, nrow(acm_enc[acm_enc$Lang_Other == 1, ]) / N))
  
  # Math Ability
  distros$math <- nrow(acm_enc[acm_enc$Math.Confidence == 1,]) / N
  
  # Gender
  distros$gender <- nrow(acm_enc[(acm_enc$Male == 1) | (acm_enc$Other.Gender == 1), ]) / N
  
  distros
}

# I derived this function mildly arbitrarily. The logic is that we probably want at least one spanish speaker at a school, but there are then diminishing returns.  It scales so that for a school that 100% hispanic, we would aim to have 2.6 spanish speakers on the team.  A team thats 80% hispanic will aim to have 4. The main problem with this approach is that we may create too many spots for spanish speakers, or have not have enough spanish speakers for the intended spots.  
# Shifted down by 75% for LA, since everyone has over 80% Hispanic
spanishNeed <- function(x) {
  1.5772*log(100*x-70) - 2.1205
}

# Directly calculates the expected number of ACMs per team for each of the markers.
# My methodology is to aim for a uniform distribution when it makes sense.

school_config <- function(school_df, acm_enc){
  # Precalculate some helpful counts
  corps_demos <- corps_demographic_targets(school_df, acm_enc)
  # Unravel list into some variables.  Mostly so that the code is a little cleaner later.
  education <- corps_demos$education
  lang <- corps_demos$lang
  tut_exp <- corps_demos$tut_exp
  math <- corps_demos$math
  gender <- corps_demos$gender
  
  
  
  school.data <- select(school_df, `sch_id`, School, `Team Size`, GradeLevel, `% Hispanic`) %>%
    rename(size = `Team Size`,
           span = GradeLevel) %>%
    mutate(HSGrad_tgt = ifelse(span=="High", 0, education[education$level %in% 'HS',]$ratio * as.numeric(size)),
           SomeCol_tgt = education[education$level %in% 'SomeCol',]$ratio * as.numeric(size),
           TutExp = as.numeric(size) * tut_exp[tut_exp$HasTutored == 1,]$ratio,
           SpanishNeed = pmax(spanishNeed(`% Hispanic`), 1),# This sets a minimum of 1 spanish speaker per team.  This might make sense in LA, but not other places.
           OtherLang_tgt = lang[lang$ability %in% 'other',]$ratio * as.numeric(size),
           Math_tgt = ifelse(span=="Elementary", as.numeric(size)*.5*math, ifelse(span=="Middle", .75*as.numeric(size)*math, as.numeric(size)*math)),
           Male_tgt = as.numeric(size)*gender) 
}

# Initial Team Placements

# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots

initial_placement <- function(acm_enc, school_targets){
  # First place acm's at schools designated by Manual.Placement column
  # NOTE: Removed seed parameter.  Seed is used for reproducability, but we want randomness in the start.
  
  # first create an empty list
  team_placements = list()
  
  acms_with_Manual.Placement <- acm_enc %>%
                                  left_join(., select(school_targets, sch_id:School), 
                                            by=c("Manual.Placement" = "School")) %>%
                                  filter(!is.na(sch_id))
  
  filled_slot_counts <- acms_with_Manual.Placement %>%
                          group_by(sch_id) %>%
                          summarise(filled = n())
  
  team_size_targets <- select(school_targets, sch_id:size) %>%
                        left_join(., filled_slot_counts, by=("sch_id")) %>%
                        replace_na(list(filled = 0)) %>%
                        mutate(unfilled_slots = as.numeric(size) - as.numeric(filled))
  
  # use a for-loop to read each team size
  for (x in team_size_targets$sch_id){
    team_slots = list(
      # create a list that repeats each school 'id' for the size of each team
      rep(x, 
          subset(team_size_targets$unfilled_slots, team_size_targets$sch_id == x)
          )
      )
    team_placements <- c(team_placements, team_slots)
  }
  
  team_placements <- data.frame(placement=unlist(team_placements))
  
  slots <- nrow(team_placements)
  filled_acm_roster <- c(acm_enc[is.na(acm_enc$Manual.Placement), ]$acm_id, 9000:(9000 + slots - nrow(acm_enc[is.na(acm_enc$Manual.Placement), ]) - 1))
  
  # Randomize Starting Place
  
  team_placements_df <- data.frame(sch_id=team_placements[sample(nrow(team_placements), replace=F), ],
                                   acm_id= filled_acm_roster) %>%
                        union(., select(acms_with_Manual.Placement, sch_id, acm_id)) %>%
                        rename(placement = sch_id)
  
  
  # Merge team_placements_df with acm_df on the 'id' column
  team_placements_df <- left_join(team_placements_df, acm_enc, by = "acm_id") %>%
                        replace_na(replace = list(Math.Confidence = 0, Ed_HS = 0, Ed_SomeCol = 0, Ed_Col = 0,
                                                  HasTutored = 0, SpanishAble = 0, Lang_Other = 0, Male = 0, 
                                                  Other.Gender =0, Race.Ethnicity.Hispanic = 0, 
                                                  Race.Ethnicity.Asian = 0, Race.Ethnicity.White = 0, 
                                                  Race.Ethnicity.Black = 0, days_old = 0))
  
  
  # Honor Manual Placements
  sch_id_names <- school_df[, c("sch_id", "School")]
  colnames(sch_id_names) <- c("Manual.Placement_id", "School.Name")
  team_placements_df <- merge(team_placements_df, sch_id_names, by.x = "Manual.Placement", by.y = "School.Name", all.x = TRUE)

  # We would like to ensure that high school students get placed in ES or MS
  acms_for_swaps <- merge(team_placements_df[is.na(team_placements_df$Manual.Placement_id), ], school_targets, by.x = "placement", by.y = "sch_id", all.x = TRUE)
  
  #print(acms_for_swaps)
    
  hs_acms_to_swap <- acms_for_swaps[(acms_for_swaps$Ed_HS == 1) & (acms_for_swaps$span == "High"),]
  acms_to_swap_with <- acms_for_swaps[(acms_for_swaps$Ed_HS == 0) & (acms_for_swaps$span != "High"),]
  acms_to_swap_with <- acms_to_swap_with[sample(nrow(acms_to_swap_with), nrow(hs_acms_to_swap), replace=F), ]
  
  team_placements_df[team_placements_df$acm_id %in% hs_acms_to_swap$acm_id, ]$placement <- acms_to_swap_with$placement
  team_placements_df[team_placements_df$acm_id %in% acms_to_swap_with$acm_id, ]$placement <- hs_acms_to_swap$placement
 
  return(team_placements_df)
}


# Calculate score


hs_loss <- function(targets, actuals){
  loss <- ifelse(targets == 0, (targets - actuals) * -1e10, (targets - actuals)^2)
  sum(loss)
}

reqd_spanish_loss <- function(targets, actuals, min_reqd = 1){
  loss <- ifelse(actuals < min_reqd, 1e10, (targets - actuals)^2)
  sum(loss)
}

reqd_males <- function(targets, actuals, min_reqd = 1){
  loss <- ifelse(actuals < min_reqd, 1e10, (targets - actuals)^2)
  sum(loss)
}

calculate_score = function(team_placements_df, school_targets, gender_target=gender_g) {
  
  #team_placements_df <- bestPlacement$best_placements %>% filter(acm_id < 9000)
  
  # Merge  with school_df to pull in school characteristics
  team_placements_df <- team_placements_df %>%
                          left_join(., school_targets, by=c("placement" = "sch_id")) %>%
                          filter(acm_id < 9000)
  
  # Store each score in a list
  scores = list()
  
  #################
  # COMMUTE SCORE #
  #################
  
  # This score is simply the sum number of seconds each ACM travels to their assigned school
  
  commutes = team_placements_df %>% 
              mutate(acm_dest_id = paste(acm_id, "-", placement)) %>%
              left_join(., acm_commutes, by="acm_dest_id") %>%
              replace_na(replace = list("dist" = 0))
  
  # Take the sqrt to scale the value closer to the other features
  scores$commute_score <- mean(commutes$dist)
  
  #############
  # AGE SCORE #
  #############
  
  # This score is the difference between the [overall age variance across the corps] and [overall average of each team's average age variance]

  age_var <- team_placements_df %>%
              group_by(placement) %>%
              summarize(age_var = var(days_old)) %>%
              filter(!is.na(age_var)) %>%
              ungroup() %>%
              summarize(avg_age_var = mean(age_var))

  scores$age_score <- sqrt(abs(age_var$avg_age_var - var(team_placements_df$days_old)))
  
  ###################
  # ETHNICITY SCORE #
  ###################
  
  # This score is the overall average of each team's average % representation that each teammate experiences. For example, 0.44 means that for the average team, the average teammate experiences that his/her personal ethnicity is represented in 44% of the team.
  
  ethnicity_eths <- 
    team_placements_df %>%
    group_by(placement, 
             Race.Ethnicity.Black, 
             Race.Ethnicity.White, 
             Race.Ethnicity.Asian,
             Race.Ethnicity.Hispanic) %>%
    dplyr::summarize(n_eths = n()) %>%
    group_by(placement) %>%
    dplyr::mutate(pct_eths = n_eths/sum(n_eths) * n_eths / sum(n_eths)) %>%
    dplyr::mutate(avg_eths_rep = sum(pct_eths)) %>%
    summarize(avg_eths_rep = mean(avg_eths_rep)) %>%
    summarize(avg_eths_rep = mean(avg_eths_rep))

  scores$ethnicity_score <- (ethnicity_eths$avg_eths_rep*1000)
  
  #################
  #    Scoring    #
  #################  
  
  placed <- team_placements_df %>%
                group_by(placement) %>%
                summarise(HS_Grads = sum(Ed_HS),
                          SomeCol = sum(Ed_SomeCol),
                          Tutoring = sum(HasTutored),
                          Spanish = sum(SpanishAble),
                          OtherLang = sum(Lang_Other),
                          MathAble = sum(Math.Confidence),
                          Males = sum(Male)) %>%
                left_join(., school_targets, by=c("placement" = "sch_id"))
  
  scores$Edscore <- hs_loss(placed$HSGrad_tgt, placed$HS_Grads) + sum((placed$SomeCol_tgt - placed$SomeCol)^2)
  scores$Tutoring <- sum((placed$TutExp - placed$Tutoring)^2)
  scores$Spanish <- (reqd_spanish_loss(placed$SpanishNeed, placed$Spanish, min_reqd = 1) + sum((placed$OtherLang_tgt - placed$OtherLang)^2))
  scores$Math <- sum((placed$Math_tgt - placed$MathAble)^2)
  scores$Gender <- reqd_males(placed$Male_tgt, placed$Males, 1)

  #################
  # OVERALL SCORE #
  #################
  
  scores$aggr_score <- sum(unlist(scores))
  
  return(scores)
}


# Temperature Function

current_temperature = function(iter, s_curve_amplitude, s_curve_center, s_curve_width) {
  s_curve_amplitude * s_curve(iter, s_curve_center, s_curve_width)
}

s_curve = function(x, center, width) {
  1 / (1 + exp((x - center) / width))
}

# Annealing and Swap Function

run_intermediate_annealing_process = function(starting_placements, school_df, best_placements=starting_placements, best_score=1e12, starting_iteration=1, number_of_iterations, center_scale=0.1, width_scale=0.1) {
  
   #starting_placements = team_placements_df 
   #school_df = school_targets
   #best_placements = team_placements_df 
   #best_score = 142078800000
   #starting_iteration = 1
   #number_of_iterations = 10000
   #s_curve_amplitude = 4000
   #s_curve_center = 0
   #s_curve_width = 3000
   
  team_placements_df <- starting_placements
  
  placement_score <- calculate_score(team_placements_df, school_df)$aggr_score
  trace <- data.frame(iter=c(1:number_of_iterations), score=0, temp=0, ratio=0)
  trace[1, 2] <- placement_score

  for(i in 1:number_of_iterations) {
    iter = starting_iteration + i
    temp = current_temperature(iter, 3000, number_of_iterations * center_scale, number_of_iterations * width_scale)
    candidate_placements_df <- team_placements_df
    
    acms_no_Manual.Placement <- subset(candidate_placements_df, (is.na(candidate_placements_df$Manual.Placement)))

    # Choose 2 schools at random
    schools_to_swap = sample(school_df$sch_id, 2)

    # Choose 1 ACM from each of those schools. Select only ACMs who have no Manual.Placement
    swap1 = sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == schools_to_swap[1] ], 1)
    swap2 = sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == schools_to_swap[2] ], 1)

    swap_school_1 = acms_no_Manual.Placement$placement[acms_no_Manual.Placement$acm_id == swap1]
    swap_school_2 = acms_no_Manual.Placement$placement[acms_no_Manual.Placement$acm_id == swap2]
    
    # Swap the team assignment of those 2 ACMs - NOTE this is done by index, but we use acm_id as index
    candidate_placements_df$placement[candidate_placements_df$acm_id == swap1] <- swap_school_2
    candidate_placements_df$placement[candidate_placements_df$acm_id == swap2] <- swap_school_1
    
    candidate_score = calculate_score(candidate_placements_df, school_df)
    trace[i+1, 2] <- candidate_score$aggr_score
    
    # Current implamentation of temperature never hits zero. 
    if (temp > 0) {
      ratio = exp((placement_score - candidate_score$aggr_score) / temp)
    } else {
      ratio = as.numeric(candidate_score$aggr_score < placement_score)
    }
    
    trace[i+1, 3] <- temp
    trace[i+1, 4] <- ratio
    
    if (runif(1) < ratio) {
      team_placements_df = candidate_placements_df
      placement_score = candidate_score$aggr_score
      all_scores = candidate_score
      
      if (placement_score < best_score) {
        best_placements = team_placements_df
        best_score = placement_score
        best_score_diff = all_scores
      }
    }
  }
  
  # Merge in School characteristics
  best_placements <- merge(best_placements, school_df, by.x = "placement", by.y = "sch_id", all.x = TRUE)
  
  best_placements <- best_placements[order(best_placements$placement),]
  
  return(list(best_placements=best_placements, 
              best_score=best_score,
              diff_scores=best_score_diff,
              trace=trace))
}

# Visualize Error Over Time

traceplot <- function(trace){
  library(ggplot2)

  ggplot(data = trace, aes(x = iter, y = score)) +
    geom_point() +
    coord_cartesian(ylim = c(1e10, 1e10+2800))
}

tempplot <- function(trace){
  library(ggplot2)
  
  ggplot(data = trace, aes(x = iter)) +
    geom_point(aes(y=ratio)) +
    geom_line(aes(y=temp)) +
    coord_cartesian(ylim = c(0, 2800))
}
```

```{r S-Curve Tuning}
library(ggplot2)
plot_curve <- function(iters){
  # Derived these ratios based on the desired shape of the graph.  
  # Traits that were desirable were about 50% being highly volotile and the other half not.
  # Wants to give it enough to to be conservative as well. 
  data <- data.frame(x = 1:iters, y = current_temperature(1:iters, 1000, iters * .1, iters * .05))
  
  ggplot(data, aes(x, y)) +
    geom_line()
}
#plot_curve(10000)
```


```{r Full Application}
# Full Application

library(readxl)
library(dplyr)
library(tidyr)

#root_dir = "C:\\Users\\perus\\OneDrive\\Documents\\GitHub\\ACM-School-Placement\\"
root_dir = "C:\\Users\\aperusse\\GitHub\\ACM-School-Placement\\"

acm_df <- read_excel(path = paste(root_dir, "Input 1 - LA ACM Data.xlsx", sep = ""), col_types = c("text", "text", "text", "text","text","text","date", "numeric", "text","text","numeric", "text","text","text"))

# This part not necessary in PowerBI, since dates are read in as %m/%d/%Y already
acm_df$Birth.Date <- format(as.Date(acm_df$Birth.Date), "%m/%d/%Y")

acm_enc <- encode_acm_df(acm_df)

school_df <- read_excel(path = paste(root_dir, "Input 3 - LA School Data.xlsx", sep = ""))
acm_commutes <- read_excel(path = paste(root_dir, "Input 2 - LA ACM Commutes.xlsm", sep = ""),
                           col_names = c("acm_id", "ACM", "From", "dest", "To", "dist", "time", "min", "blank"),
                           col_types = c("numeric", "text", "text", "text", "text", "numeric", "date", "numeric", "blank"), skip=1) %>%
                left_join(., school_df, by = c("dest" = "School")) %>%
                mutate(acm_dest_id = paste(acm_id, "-", sch_id))

# Precalculate school targets
school_targets <- school_config(school_df, acm_enc)

placement <- function(acm_enc, school_targets, number_iterations, center_scale, width_scale) {
  team_placements_df <- initial_placement(acm_enc, school_targets)
  #validity <- left_join(team_placements_df, school_targets, by=c("placement" = "sch_id"))  
  output <- run_intermediate_annealing_process(starting_placements = team_placements_df, school_df = school_targets, best_placements = team_placements_df, best_score = 1e12, starting_iteration = 1, number_of_iterations = number_iterations, center_scale=center_scale, width_scale=width_scale)
}

# best_placements <- output$best_placements
# 
# # Playing around with methods to get more info in the output. It's probably better to just re-calculate these in visualizations...
# best_placements$best_score <- output$best_score
# best_placements$ethnicity_score <- output$diff_scores$ethnicity_score
# best_placements$commute_score <- output$diff_scores$commute_score
# 
# diff_scores <- output$diff_scores
# 
# trace <- output$trace
```

```{r Single Run}

Single_Run <- placement(acm_enc, school_targets, 10000, center_scale=runif(1, 1e-3, 0.25), width_scale=runif(1, 1e-3, 0.25))

#View(Single_Run$best_placements)
traceplot(Single_Run$trace)

```

```{r In Parallel}
library(doSNOW)
library(foreach)
library(gridExtra)

n_processors = 8
cl <- makeCluster(n_processors)
registerDoSNOW(cl)

n_runs = 1*n_processors
n_iters = 25000

Runs <- foreach(i=1:n_runs) %dopar% {
  library(dplyr)
  library(tidyr)
  #print(system.time(placement(acm_enc, school_targets, 25000)))
  placement(acm_enc, school_targets, n_iters, center_scale=runif(1, 1e-3, 0.15), width_scale=runif(1, 1e-3, 0.2))
}

stopCluster(cl)
```


```{r Running Validity Checks}

best_run <- which.min(sapply(Runs, "[", i=2))

ax <- traceplot(Runs[[best_run]]$trace)
bx <- tempplot(Runs[[best_run]]$trace)
plot(grid.arrange(ax, bx, ncol=2))
#print(Runs[[i]]$diff_scores)

bestPlacement <- Runs[[best_run]]

aggregate_features <- function(df){
  validate_placement <- df %>%
                        mutate(acm_dest_id = paste(acm_id, "-", placement)) %>%
                        left_join(., acm_commutes, by="acm_dest_id") %>%
                        replace_na(replace = list("dist" = 0)) %>%
                        group_by(School, placement) %>%
                        summarise(HS_Grads = sum(Ed_HS),
                                  SomeCol = sum(Ed_SomeCol),
                                  Tutoring = sum(HasTutored),
                                  Spanish = sum(SpanishAble),
                                  OtherLang = sum(Lang_Other),
                                  MathAble = sum(Math.Confidence),
                                  Males = sum(Male), 
                                  Gender.Other = sum(Other.Gender),
                                  Hispanic.Latino = sum(Race.Ethnicity.Hispanic),
                                  Asian.PI = sum(Race.Ethnicity.Asian), 
                                  White = sum(Race.Ethnicity.White),
                                  Black = sum(Race.Ethnicity.Black),
                                  AvgCommute = mean(dist))
}

validate <- aggregate_features(bestPlacement$best_placements)

#write.csv(bestPlacement$best_placements, file = "outputs/acm_placements.csv")
#write.csv(school_targets, file="outputs/school_targets.csv")
#write.csv(placements_and_commute, file="outputs/placements_with_commutes.csv")
```

```{r Post Placement Visualization}
placement <- read.csv("acm_Placements.csv")

# placements_and_commute <- placement %>%
#                             mutate(acm_dest_id = paste(acm_id, "-", placement)) %>%
#                             left_join(., select(acm_commutes, acm_dest_id, dist), by="acm_dest_id") %>%
#                             replace_na(replace = list("dist" = 0))

school_totals_and_targets <- aggregate_features(placement) %>%
                              left_join(., select(school_targets, -School), by=c("placement" = "sch_id"))



```

