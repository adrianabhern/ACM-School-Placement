---
title: "ACM School Placement"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Install Packages

```{r install packages, echo = FALSE}
install.packages("gmapsdistance")
install.packages("readxl")
```

# Load Packages

```{r load packages}
library("gmapsdistance")
library("readxl")
```

# Read Data

This is fake data that may or may not represent an actual corps.

```{r load spreadsheets, echo=FALSE}
acm_df <- read_excel(path = "Input 1 - ACM Data.xls")
school_df <- read_excel(path = "Input 2 - School Data.xls")

# Add an index column for schools
school_df$id <- 1:nrow(school_df)
acm_df$id <- 1:nrow(acm_df)

```

# Calculate Commutes

To calculate commute times, we essentially send many requests to Google Maps through an API (Applciation Program Interface). To get access to the API we need a key. Visit the [Google Distance Matrix API](https://developers.google.com/maps/documentation/distance-matrix/) page. Click "GET A KEY" in the upper right corner. Save the key privately. This key identifies you to Google.

Many organizations provide access to their data through an API. Many times this service is free, but some organizations charge for this service because of processing costs and the benefits that this access enables. Google will allow you to calculate 2,500 travel times for free in one day. After that, you will need to pay $0.50 for each 1,000 requests, or wait a day to calculate 2,500 more.

The key I included in this script is a free-use key, so it will be limited to 2,500 results per day. However, I did opt to enable pay-as-you-go on my personal key (not shared here). In CYCHI, this expense will hopefully be covered under our Impact Team budget.

```{r commute times}
# Prior to this step, you may need to ensure that "Address.Line.1" does not include any apartment/suite/room info.

# This line combines address data into one text string:
acm_df[["Full Address"]] = paste(acm_df[["Address Line 1"]], acm_df[["City"]], acm_df[["State"]], acm_df[["Postal Code"]])

# Replace spaces with "+" and remove commas (requests to google maps API cannot include spaces)
acm_df[["Full Address"]] = gsub(" ", "+", acm_df[["Full Address"]])
school_df[["Address"]] = gsub(" ", "+", school_df[["Address"]])
school_df$"Address" = gsub(",", "", school_df$"Address")

# Input your own API Key here
set.api.key("AIzaSyDFlU9RkmJBJdw0YGMswYECXQeZeKxFmuc")

# Create an empty data frame that we will fill with commute times
acm_commutes <- data.frame(Ints=integer())

# Create a for loop that will read through each row of ACM data, feed it into the main function of our gmapsdistance package, and build a new data frame of commute info.
for (acm_id in acm_df[1:2,]$id){
  # select just one row from acm_df, and assign it to a new object, acm_row
  acm_row <- subset(acm_df, id == acm_id)
  # feed that ACM's address and mode into the function 'gmapsdistance'. This will return a new object that is a single row of ACM commute times to each school. That row is assigned to a new object, 'commute'
  commute = gmapsdistance(origin = acm_row$"Full Address", destination = school_df[1:2,]$"Address", mode = acm_row$"Method of Commute", combinations = "all", shape = "wide")
  # create an 'id' column in our new 'commute' row that is the same as acm_id. We will use this to join our data frames.
  commute$Time[["id"]] = acm_id
  # as the for-loop runs, progressively add each single row of commute data into a new data frame called acm_commutes. As this for-loop runs, this data frame grows to include all ACM's.
  acm_commutes <- rbind(acm_commutes, commute$Time)
}

# Finally, combine our original input 'acm_df' with our new data frame of commute times 'acm_commutes', and overwrite our original acm_df with this newly combined data frame.
acm_df <- merge(acm_df, acm_commutes, by = "id", all = TRUE)

```



# Build Requirements

```{r generate logic for invalid assignments}
# E.g., can't allow staff with age < 21 into an HS

IsValid <- function(assign){
  valid <- ifelse(any(assign < 9), FALSE, TRUE) 
  return(valid)
}
```


```{r randomly generate initial assignment}

random.gen <- function(acm_df, school_df){
  nSch <- nrow(school_df)
  nStu <- nrow(acm_df)
  team.size <- ceiling(nStu/nSch)
  assign <- rep(school_df$id, each = team.size) # Creates a vector of 1 10 times, 2 10 times, etc
  random <- sample(x = assign, size = nStu)
    # table(random) # ... This displays a tabulation of the assigned schools
  return(random)
}

repeat{
  myAssign <- random.gen(acm_df, school_df)
  table(myAssign)
  if (IsValid(myAssign)) break
}
```

```{r generate proposal function for algorithm's steps}
GenProp <- function(myAssign){
  # picks random to and from schools, and swaps those assignments
  # returns the full assignment
}
```


```{r create objective function}
Obj <- function(myAssign){
  # Takes the assignment, and calculations an objective score combining:
  # 1. minimize commute time
  # 2. college experience or age >= 21 for HS (might also be requirement for valid proposal)
  # 3. bonus for demographic balance (e.g. gender, race/eth, ed)
  # 4. grade-level and perhaps even school preferences
  
  
}
```

```{r create a temperature schedule as a function of step number}

```

```{r implement SA algorithm}

```


* picking initial 'direction'
  * how to set up function to know that there are teams of 9 (or 8, 7, 10, etc)
  * output: series (1, 1, 1, 1, 2, 2, 2, 2, 3, 3, etc.)
* Identify right solution algorithm for our setup
  * GenSA
  * gaoptim -- is for permutation-based problems
  * roll our own (Nick has code for this)

