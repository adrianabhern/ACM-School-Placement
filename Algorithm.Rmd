---
title: "ACM School Placement"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Install Packages

```{r install packages, echo = FALSE}
install.packages("gmapsdistance")
install.packages("readxl")
```

# Load Packages

```{r load packages}
library("gmapsdistance")
library(readxl)
```

# Read Data

This is fake data that may or may not represent an actual corps.

```{r load spreadsheets, echo=FALSE}
acm_df <- read_excel(path = "Input 1 - ACM Data.xls")
school_df <- read_excel(path = "Input 2 - School Data.xls")

# Add an index column for schools
school_df$id <- 1:nrow(school_df)

```

# Calculate Commutes

To calculate commute times, we essentially send many requests to Google Maps through an API (Applciation Program Interface). To get access to the API we need a key. Visit the [Google Distance Matrix API](https://developers.google.com/maps/documentation/distance-matrix/) page. Click "GET A KEY" in the upper right corner. Save the key in a safe place. This key identifies you to Google, and you will need it for this script.

Many organizations provide access to their data through an API. Many times this service is free, but some organizations change for this service because of processing costs and the power that this access enables. Google will allow you to calculate 2,500 travel times for free in one day. After that, you will need to pay $0.50 for each 1,000 requests, or wait a day to calculate 2,500 more.

The key I included in this script is a free-use key, so it will be limited to 2,500 results per day. However, I did opt to enable pay-as-you-go on my personal key. In CYCHI, this expenses will hopefully be covered under our Impact Team budget.

Current Limitations:
* mode of commute can only be a single object, not an array of different commute preferences for each ACM

```{r commute times}
# Prior to this step, you may need to ensure that "Address.Line.1" does not include any apartment/suite/room info.
# This line combines address data into one text string:

acm_df[["Full Address"]] = paste(acm_df[["Address Line 1"]], acm_df[["City"]], acm_df[["State"]], acm_df[["Postal Code"]])

# Replace spaces with "+" and remove commas (queries to google maps cannot include spaces)
acm_df[["Full Address"]] = gsub(" ", "+", acm_df[["Full Address"]])
school_df[["Address"]] = gsub(" ", "+", school_df[["Address"]])
school_df$"Address" = gsub(",", "", school_df$"Address")

# Input your own API Key here
set.api.key("AIzaSyDFlU9RkmJBJdw0YGMswYECXQeZeKxFmuc")

# There will likely be a warning prompt because some corps members are roommates. The warning is because there are duplicate origin addresses.
results = gmapsdistance(origin = acm_df[1:2,]$"Full Address", destination = school_df[1:2,]$"Address", mode = "driving", combinations = "all", shape = "wide")

#cbind combines two tables
acm_data = cbind(acm_data, results)

```


# Build Requirements

```{r generate logic for invalid assignments}
# E.g., can't allow staff with age < 21 into an HS

IsValid <- function(assign){
  valid <- ifelse(any(assign < 9), FALSE, TRUE) 
  return(valid)
}
```


```{r randomly generate initial assignment}

random.gen <- function(acm_df, school_df){
  nSch <- nrow(school_df)
  nStu <- nrow(acm_df)
  team.size <- ceiling(nStu/nSch)
  assign <- rep(school_df$id, each = team.size) # Creates a vector of 1 10 times, 2 10 times, etc
  random <- sample(x = assign, size = nStu)
    # table(random) # ... This displays a tabulation of the assigned schools
  return(random)
}

repeat{
  myAssign <- random.gen(acm_df, school_df)
  table(myAssign)
  if (IsValid(myAssign)) break
}
```

```{r generate proposal function for algorithm's steps}
GenProp <- function(myAssign){
  # picks random to and from schools, and swaps those assignments
  # returns the full assignment
}
```


```{r create objective function}
Obj <- function(myAssign){
  # Takes the assignment, and calculations an objective score combining:
  # 1. minimize commute time
  # 2. college experience or age >= 21 for HS (might also be requirement for valid proposal)
  # 3. bonus for demographic balance (e.g. gender, race/eth, ed)
  # 4. grade-level and perhaps even school preferences
  
  
}
```

```{r create a temperature schedule as a function of step number}

```

```{r implement SA algorithm}

```


* picking initial 'direction'
  * how to set up function to know that there are teams of 9 (or 8, 7, 10, etc)
  * output: series (1, 1, 1, 1, 2, 2, 2, 2, 3, 3, etc.)
* Identify right solution algorithm for our setup
  * GenSA
  * gaoptim -- is for permutation-based problems
  * roll our own (Nick has code for this)

