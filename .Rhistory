current_temperature = function(iter, s_curve_amplitude, s_curve_center, s_curve_width) {
s_curve_amplitude * s_curve(iter, s_curve_center, s_curve_width)
}
s_curve = function(x, center, width) {
1 / (1 + exp((x - center) / width))
}
calculate_score = function(acm_df, team_placements_df) {
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
acm_commutes <- data.frame()
for (x in acm_df_with_placements$id){
acm_row <- subset(acm_df_with_placements, id == x)
acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
colMeans(acm_commutes[1])
}
run_intermediate_annealing_process = function(acm_df, team_placements, placement_score, best_placements, best_score, starting_iteration, number_of_iterations, s_curve_amplitude, s_curve_center, s_curve_width) {
n_acms = nrow(acm_df)
for(i in 1:number_of_iterations) {
iter = starting_iteration + i
temp = current_temperature(iter, s_curve_amplitude, s_curve_center, s_curve_width)
candidate_placements = team_placements
candidate_placements_df = data.frame(index=1:length(candidate_placements), candidate_placements)
schools_to_swap = sample(1:nrow(school_df), 2)
swap1 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[1]], 1)
swap2 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[2]], 1)
replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
candidate_score = calculate_score(acm_df, candidate_placements)
if (temp > 0) {
ratio = exp((placement_score - candidate_score) / temp)
} else {
ratio = as.numeric(candidate_score < placement_score)
}
if (runif(1) < ratio) {
team_placements = candidate_placements
placement_score = candidate_score
if (placement_score < best_score) {
best_placements = team_placements
best_score = placement_score
}
}
}
return(list(team_placements=team_placements, placement_score=placement_score, best_placements=best_placements, best_score=best_score))
}
acm_df <- read_excel(path = "Input 1 - ACM Data.xls")
school_df <- read_excel(path = "Input 2 - School Data.xls")
# For some reason there is an empty row at the end of acm_df, so it's removed here:
acm_df <- acm_df[-nrow(acm_df),]
# Add an index column for schools and acm's
school_df$id <- 1:nrow(school_df)
acm_df$id <- 1:nrow(acm_df)
# set.api.key("AIzaSyDFlU9RkmJBJdw0YGMswYECXQeZeKxFmuc")
# gmapsdistance(origin = "", destination = "36+S+Wabash+Ave+Chicago+IL", mode = "transit", combinations = "all", dep_date = "2017-06-12", dep_time = "08:00:00", shape = "wide")
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_df)){
team_slots = list(
# create a list that repeats the school 'id' for the size of each team
rep(x,
subset(school_df$`Team Size`, school_df$`id` == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- unlist(team_placements)
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
calculate_score = function(acm_df, team_placements_df) {
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
acm_commutes <- data.frame()
for (x in acm_df_with_placements$id){
acm_row <- subset(acm_df_with_placements, id == x)
acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
colMeans(acm_commutes[1])
}
calculate_score = function(acm_df, team_placements_df) {
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
acm_commutes <- data.frame()
for (x in acm_df_with_placements$id){
acm_row <- subset(acm_df_with_placements, id == x)
acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
colMeans(acm_commutes[1])
}
calculate_score = function(acm_df, team_placements) {
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
acm_commutes <- data.frame()
for (x in acm_df_with_placements$id){
acm_row <- subset(acm_df_with_placements, id == x)
acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
colMeans(acm_commutes[1])
}
calculate_score(acm_df, team_placements)
current_temperature = function(iter, s_curve_amplitude, s_curve_center, s_curve_width) {
s_curve_amplitude * s_curve(iter, s_curve_center, s_curve_width)
}
s_curve = function(x, center, width) {
1 / (1 + exp((x - center) / width))
}
run_intermediate_annealing_process = function(acm_df, team_placements, placement_score, best_placements, best_score, starting_iteration, number_of_iterations, s_curve_amplitude, s_curve_center, s_curve_width) {
n_acms = nrow(acm_df)
for(i in 1:number_of_iterations) {
iter = starting_iteration + i
temp = current_temperature(iter, s_curve_amplitude, s_curve_center, s_curve_width)
candidate_placements = team_placements
candidate_placements_df = data.frame(index=1:length(candidate_placements), candidate_placements)
schools_to_swap = sample(1:nrow(school_df), 2)
swap1 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[1]], 1)
swap2 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[2]], 1)
replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
candidate_score = calculate_score(acm_df, candidate_placements)
if (temp > 0) {
ratio = exp((placement_score - candidate_score) / temp)
} else {
ratio = as.numeric(candidate_score < placement_score)
}
if (runif(1) < ratio) {
team_placements = candidate_placements
placement_score = candidate_score
if (placement_score < best_score) {
best_placements = team_placements
best_score = placement_score
}
}
}
return(list(team_placements=team_placements, placement_score=placement_score, best_placements=best_placements, best_score=best_score))
}
run_intermediate_annealing_process(acm_df, team_placements, placement_score = 1802, best_placements = team_placements, best_score = 1802, starting_iteration = 1, number_of_iterations = 200, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
calculate_score = function(acm_df, team_placements) {
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
acm_commutes <- data.frame()
for (x in acm_df_with_placements$id){
acm_row <- subset(acm_df_with_placements, id == x)
acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
sum(acm_commutes[1])
}
calculate_score(acm_df, team_placements)
run_intermediate_annealing_process(acm_df, team_placements, starting_iteration = 1, number_of_iterations = 200, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 200, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
knitr::opts_chunk$set(echo = TRUE)
acm_df <- read_excel(path = "Input 1 - ACM Data.xls")
library("gmapsdistance")
library("readxl")
acm_df <- read_excel(path = "Input 1 - ACM Data.xls")
school_df <- read_excel(path = "Input 2 - School Data.xls")
# For some reason there is an empty row at the end of acm_df, so it's removed here:
acm_df <- acm_df[-nrow(acm_df),]
# Add an index column for schools and acm's
school_df$id <- 1:nrow(school_df)
acm_df$id <- 1:nrow(acm_df)
# set.api.key("AIzaSyDFlU9RkmJBJdw0YGMswYECXQeZeKxFmuc")
# gmapsdistance(origin = "", destination = "36+S+Wabash+Ave+Chicago+IL", mode = "transit", combinations = "all", dep_date = "2017-06-12", dep_time = "08:00:00", shape = "wide")
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_df)){
team_slots = list(
# create a list that repeats the school 'id' for the size of each team
rep(x,
subset(school_df$`Team Size`, school_df$`id` == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- unlist(team_placements)
calculate_score = function(acm_df, team_placements) {
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
acm_commutes <- data.frame()
for (x in acm_df_with_placements$id){
acm_row <- subset(acm_df_with_placements, id == x)
acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
sum(acm_commutes[1])
}
#calculate_score(acm_df, team_placements)
current_temperature = function(iter, s_curve_amplitude, s_curve_center, s_curve_width) {
s_curve_amplitude * s_curve(iter, s_curve_center, s_curve_width)
}
s_curve = function(x, center, width) {
1 / (1 + exp((x - center) / width))
}
candidate_placements = team_placements
candidate_placements_df = data.frame(index=1:length(candidate_placements), candidate_placements)
schools_to_swap = sample(1:nrow(school_df), 2)
swap1 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[1]], 1)
swap2 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[2]], 1)
replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
candidate_placements = replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
candidate_score = calculate_score(acm_df, candidate_placements)
calculate_score(acm_df, candidate_placements)
current_temperature = function(iter, s_curve_amplitude, s_curve_center, s_curve_width) {
s_curve_amplitude * s_curve(iter, s_curve_center, s_curve_width)
}
s_curve = function(x, center, width) {
1 / (1 + exp((x - center) / width))
}
run_intermediate_annealing_process = function(acm_df, team_placements, placement_score, best_placements, best_score, starting_iteration, number_of_iterations, s_curve_amplitude, s_curve_center, s_curve_width) {
n_acms = nrow(acm_df)
for(i in 1:number_of_iterations) {
iter = starting_iteration + i
temp = current_temperature(iter, s_curve_amplitude, s_curve_center, s_curve_width)
candidate_placements = team_placements
candidate_placements_df = data.frame(index=1:length(candidate_placements), candidate_placements)
schools_to_swap = sample(1:nrow(school_df), 2)
swap1 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[1]], 1)
swap2 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[2]], 1)
candidate_placements = replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
candidate_score = calculate_score(acm_df, candidate_placements)
if (temp > 0) {
ratio = exp((placement_score - candidate_score) / temp)
} else {
ratio = as.numeric(candidate_score < placement_score)
}
if (runif(1) < ratio) {
team_placements = candidate_placements
placement_score = candidate_score
if (placement_score < best_score) {
best_placements = team_placements
best_score = placement_score
}
}
}
return(list(team_placements=team_placements, placement_score=placement_score, best_placements=best_placements, best_score=best_score))
}
run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 200, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
acm_commutes <- data.frame()
acm_row <- subset(acm_df_with_placements, id == 1)[ , grepl("Time.to.", names(acm_row))]
acm_row <- subset(acm_df_with_placements, id == 1)[ , grepl("Time.to.", names(acm_df_with_placements))]
acm_row
acm_row <- (subset(acm_df_with_placements, id == 1)[ , grepl("Time.to.", names(acm_df_with_placements))])[1]
acm_row
(subset(acm_df_with_placements, id == 1)[ , grepl("Time.to.", names(acm_df_with_placements))])[1]
subset(acm_df_with_placements$Team.Placement, id == 1)
subset(acm_df_with_placements$Team.Placement, acm_df_with_placements$id == 1)
(subset(acm_df_with_placements, id == 1)[ , grepl("Time.to.", names(acm_df_with_placements))])[subset(acm_df_with_placements$Team.Placement, acm_df_with_placements$id == 1)]
(subset(acm_df_with_placements, id == 1)[ , grepl("Time.to.", names(acm_df_with_placements))])[subset(acm_df_with_placements$Team.Placement, acm_df_with_placements$id == 19)]
calculate_score = function(acm_df, team_placements) {
# Convert the team_placement list into an dataframe with an 'id' column
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
# Merge team_placements_df with acm_df on the 'id' column we just created
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
# Now we need to merge in commute information,
# but only for the appropriate destination address
# (the school each ACM was assigned to). First we
# create an empty dataframe that will hold this data.
acm_commutes <- data.frame()
for (x in acm_df_with_placements$id){
acm_commute_time = (subset(acm_df_with_placements, id == 1)[ , grepl("Time.to.", names(acm_df_with_placements))])[subset(acm_df_with_placements$Team.Placement, acm_df_with_placements$id == x)]
acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
#acm_row <- subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_row))]
#acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
#Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
#acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
sum(acm_commutes[1])
}
calculate_score(acm_df, team_placements)
acm_commutes <- rbind(acm_commutes, acm_commute_time[1,1])
calculate_score = function(acm_df, team_placements) {
# Convert the team_placement list into an dataframe with an 'id' column
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
# Merge team_placements_df with acm_df on the 'id' column we just created
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
# Now we need to merge in commute information,
# but only for the appropriate destination address
# (the school each ACM was assigned to). First we
# create an empty dataframe that will hold this data.
acm_commutes <- data.frame()
for (x in acm_df_with_placements$id){
acm_commute_time = (subset(acm_df_with_placements, id == 1)[ , grepl("Time.to.", names(acm_df_with_placements))])[subset(acm_df_with_placements$Team.Placement, acm_df_with_placements$id == x)]
acm_commutes <- rbind(acm_commutes, acm_commute_time[1,1])
#acm_row <- subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_row))]
#acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
#Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
#acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
sum(acm_commutes[1])
}
calculate_score(acm_df, team_placements)
calculate_score = function(acm_df, team_placements) {
# Convert the team_placement list into an dataframe with an 'id' column
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
# Merge team_placements_df with acm_df on the 'id' column we just created
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
# Now we need to merge in commute information,
# but only for the appropriate destination address
# (the school each ACM was assigned to). First we
# create an empty dataframe that will hold this data.
acm_commutes <- data.frame()
for (x in acm_df_with_placements$id){
acm_commute_time = (subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_df_with_placements))])[subset(acm_df_with_placements$Team.Placement, acm_df_with_placements$id == x)]
acm_commutes <- rbind(acm_commutes, acm_commute_time[1,1])
#acm_row <- subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_row))]
#acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
#Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
#acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
sum(acm_commutes[1])
}
calculate_score(acm_df, team_placements)
acm_df <- read_excel(path = "Input 1 - ACM Data.xls")
school_df <- read_excel(path = "Input 2 - School Data.xls")
# For some reason there is an empty row at the end of acm_df, so it's removed here:
acm_df <- acm_df[-nrow(acm_df),]
# Add an index column for schools and acm's
school_df$id <- 1:nrow(school_df)
acm_df$id <- 1:nrow(acm_df)
# set.api.key("AIzaSyDFlU9RkmJBJdw0YGMswYECXQeZeKxFmuc")
# gmapsdistance(origin = "", destination = "36+S+Wabash+Ave+Chicago+IL", mode = "transit", combinations = "all", dep_date = "2017-06-12", dep_time = "08:00:00", shape = "wide")
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_df)){
team_slots = list(
# create a list that repeats the school 'id' for the size of each team
rep(x,
subset(school_df$`Team Size`, school_df$`id` == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- unlist(team_placements)
calculate_score = function(acm_df, team_placements) {
# Convert the team_placement list into an dataframe with an 'id' column
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
# Merge team_placements_df with acm_df on the 'id' column we just created
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
# Now we need to merge in commute information,
# but only for the appropriate destination address
# (the school each ACM was assigned to).
for (x in acm_df_with_placements$id){
acm_commute_time = (subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_df_with_placements))])[subset(acm_df_with_placements$Team.Placement, acm_df_with_placements$id == x)]
acm_commutes <- rbind(acm_commutes, acm_commute_time[1,1])
#acm_row <- subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_row))]
#acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
#Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
#acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
sum(acm_commutes[1])
}
current_temperature = function(iter, s_curve_amplitude, s_curve_center, s_curve_width) {
s_curve_amplitude * s_curve(iter, s_curve_center, s_curve_width)
}
s_curve = function(x, center, width) {
1 / (1 + exp((x - center) / width))
}
run_intermediate_annealing_process = function(acm_df, team_placements, placement_score, best_placements, best_score, starting_iteration, number_of_iterations, s_curve_amplitude, s_curve_center, s_curve_width) {
n_acms = nrow(acm_df)
for(i in 1:number_of_iterations) {
iter = starting_iteration + i
temp = current_temperature(iter, s_curve_amplitude, s_curve_center, s_curve_width)
candidate_placements = team_placements
candidate_placements_df = data.frame(index=1:length(candidate_placements), candidate_placements)
schools_to_swap = sample(1:nrow(school_df), 2)
swap1 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[1]], 1)
swap2 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[2]], 1)
candidate_placements = replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
candidate_score = calculate_score(acm_df, candidate_placements)
if (temp > 0) {
ratio = exp((placement_score - candidate_score) / temp)
} else {
ratio = as.numeric(candidate_score < placement_score)
}
if (runif(1) < ratio) {
team_placements = candidate_placements
placement_score = candidate_score
if (placement_score < best_score) {
best_placements = team_placements
best_score = placement_score
}
}
}
return(list(team_placements=team_placements, placement_score=placement_score, best_placements=best_placements, best_score=best_score))
}
run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 200, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 1000, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
install.packages("googleway")
library("googleway")
google_directions(origin = "1344 W Eddy St Chicago IL",
destination = "City Year Chicago",
key = "AIzaSyCL3msiEG9oJ1ZMEC07bE9ZtfP8kgTQumo",
simplify = T) ## use simplify = T to return a data.frame
google_directions(origin = "1344 W Eddy St Chicago IL",
destination = "City Year Chicago",
key = "AIzaSyCL3msiEG9oJ1ZMEC07bE9ZtfP8kgTQumo",
simplify = F) ## use simplify = T to return a data.frame
google_directions(origin = "1344 W Eddy St Chicago IL",
destination = "City Year Chicago",
key = "AIzaSyCL3msiEG9oJ1ZMEC07bE9ZtfP8kgTQumo",
transit_mode = "transit",
simplify = F) ## use simplify = T to return a data.frame
google_directions(origin = "1344 W Eddy St Chicago IL",
destination = "City Year Chicago",
key = "AIzaSyCL3msiEG9oJ1ZMEC07bE9ZtfP8kgTQumo",
mode = "transit",
simplify = F) ## use simplify = T to return a data.frame
google_directions(origin = "1344 W Eddy St Chicago IL",
destination = "City Year Chicago",
key = "AIzaSyCL3msiEG9oJ1ZMEC07bE9ZtfP8kgTQumo",
mode = "transit",
simplify = T) ## use simplify = T to return a data.frame
time.taken
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
acm_df_with_placements <- merge(acm_df_with_placements, school_df, by.x = "Team.Placement", by.y = "id", all.x = TRUE)
school_df
acm_df <- read_excel(path = "Input 1 - ACM Data.xls")
school_df <- read_excel(path = "Input 2 - School Data.xls")
# For some reason there is an empty row at the end of acm_df, so it's removed here:
acm_df <- acm_df[-nrow(acm_df),]
# Add an index column for schools and acm's
school_df$id <- 1:nrow(school_df)
acm_df$id <- 1:nrow(acm_df)
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_df)){
team_slots = list(
# create a list that repeats the school 'id' for the size of each team
rep(x,
subset(school_df$`Team Size`, school_df$`id` == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- unlist(team_placements)
calculate_score = function(acm_df, team_placements) {
# Convert the team_placement list into an dataframe with an 'id' column
team_placements_df <- data.frame(id = 1:length(team_placements), Team.Placement = team_placements)
# Merge team_placements_df with acm_df on the 'id' column we just created
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
# acm_df_with_placements <- merge(acm_df_with_placements, school_df, by.x = "Team.Placement", by.y = "id", all.x = TRUE)
# for (x in unique(acm_df_with_placements$'School Name'){
# single_school_df = acm_df_with_placements[acm_df_with_placements == x]
# Calculate diversity components}
# Now we need to merge in commute information,
# but only for the appropriate destination address
# (the school each ACM was assigned to).
for (x in acm_df_with_placements$id){
# Complicated subsetting to read each ACM
acm_commute_time = (subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_df_with_placements))])[subset(acm_df_with_placements$Team.Placement, acm_df_with_placements$id == x)]
acm_commutes <- rbind(acm_commutes, acm_commute_time[1,1])
# Previous method:
#acm_row <- subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_row))]
#acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
#Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
#acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
sum(acm_commutes[1])
}
current_temperature = function(iter, s_curve_amplitude, s_curve_center, s_curve_width) {
s_curve_amplitude * s_curve(iter, s_curve_center, s_curve_width)
}
s_curve = function(x, center, width) {
1 / (1 + exp((x - center) / width))
}
run_intermediate_annealing_process = function(acm_df, team_placements, placement_score, best_placements, best_score, starting_iteration, number_of_iterations, s_curve_amplitude, s_curve_center, s_curve_width) {
n_acms = nrow(acm_df)
for(i in 1:number_of_iterations) {
iter = starting_iteration + i
temp = current_temperature(iter, s_curve_amplitude, s_curve_center, s_curve_width)
candidate_placements = team_placements
candidate_placements_df = data.frame(index=1:length(candidate_placements), candidate_placements)
schools_to_swap = sample(1:nrow(school_df), 2)
swap1 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[1]], 1)
swap2 = sample(candidate_placements_df$index[candidate_placements_df$candidate_placements == schools_to_swap[2]], 1)
candidate_placements = replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
candidate_score = calculate_score(acm_df, candidate_placements)
if (temp > 0) {
ratio = exp((placement_score - candidate_score) / temp)
} else {
ratio = as.numeric(candidate_score < placement_score)
}
if (runif(1) < ratio) {
team_placements = candidate_placements
placement_score = candidate_score
if (placement_score < best_score) {
best_placements = team_placements
best_score = placement_score
}
}
}
return(list(team_placements=team_placements, placement_score=placement_score, best_placements=best_placements, best_score=best_score))
}
start.time <- Sys.time()
run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 1000, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
end.time <- Sys.time()
time.taken <- end.time - start.time
