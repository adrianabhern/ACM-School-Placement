#print(acms_for_swaps)
hs_acms_to_swap <- acms_for_swaps[(acms_for_swaps$Ed_HS == 1) & (acms_for_swaps$span == "HS"),]
acms_to_swap_with <- acms_for_swaps[(acms_for_swaps$Ed_HS == 0) & (acms_for_swaps$span != "HS"),]
acms_to_swap_with <- acms_to_swap_with[sample(nrow(acms_to_swap_with), nrow(hs_acms_to_swap), replace=F), ]
team_placements_df[team_placements_df$acm_id %in% hs_acms_to_swap$acm_id, ]$placement = acms_to_swap_with$placement
team_placements_df[team_placements_df$acm_id %in% acms_to_swap_with$acm_id, ]$placement = hs_acms_to_swap$placement
return(team_placements_df)
}
team_placements_df <- initial_placement(acm_enc, school_targets, prevent_roommates = "No)
team_placements_df
# Initial Team Placements
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
initial_placement <- function(acm_enc, school_targets, prevent_roommates){
# First place acm's at schools designated by Manual.Placement column
# NOTE: Removed seed parameter.  Seed is used for reproducability, but we want randomness in the start.
set.seed(42)
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_targets)){
team_slots = list(
# create a list that repeats each school 'id' for the size of each team
rep(x,
subset(school_targets$size, school_targets$sch_id == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- data.frame(placement=unlist(team_placements))
team_placements_df <- data.frame(placement=team_placements[sample(nrow(team_placements), replace=F), ],
acm_id= 1:nrow(team_placements))
# Merge team_placements_df with acm_df on the 'id' column
team_placements_df <- merge(acm_enc, team_placements_df, by = "acm_id", all.x = TRUE)
# Honor Manual Placements
sch_id_names <- school_df[, c("sch_id", "School Name")]
colnames(sch_id_names) <- c("Manual.Placement_id", "School.Name")
team_placements_df <- merge(team_placements_df, sch_id_names, by.x = "Manual.Placement", by.y = "School.Name", all.x = TRUE)
# Re-sort by acm_id and reset the index
team_placements_df <- team_placements_df[order(team_placements_df$acm_id), ]
rownames(team_placements_df) <- 1:nrow(team_placements_df)
acm_ids_with_Manual.Placement <- team_placements_df$acm_id[!is.na(team_placements_df$Manual.Placement_id)]
for (x in acm_ids_with_Manual.Placement){
acms_no_Manual.Placement <- team_placements_df[is.na(team_placements_df$Manual.Placement_id), ]
swap1 <- x
x_placement <- team_placements_df[team_placements_df$acm_id == x, ]$Manual.Placement_id
# Choose 1 acm_id to swap with at the school we want to ensure manual placement is honored
# What if already assigned to that school?
eligible_acm_ids_for_swap <- acms_no_Manual.Placement$acm_id[acms_no_Manual.Placement$placement == x_placement]
acm_id_to_swap <- sample( eligible_acm_ids_for_swap, 1 )
swap2 <- acm_id_to_swap
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
# Prevent Roommates from being on the same team
if (prevent_roommates == "Yes"){
# Check each team for roommates
for (y in 1:nrow(school_targets)){
school_frame = team_placements_df[team_placements_df$placement == y, ]
dup_roommates <- unique(school_frame$Roommate.Names[duplicated(school_frame$Roommate.Names)])
dup_roommates <- dup_roommates[!is.na(dup_roommates)]
if (length(dup_roommates) != 0){
# select df rows that contain any duplicated name
for (z in  dup_roommates){
roommate_set <- school_frame[which(school_frame$Roommate.Names == z), ]
roommate_set_manual <- roommate_set[!is.na(roommate_set$Manual.Placement_id), ]
roommate_set_no_manual <- roommate_set[is.na(roommate_set$Manual.Placement_id), ]
# manual placements will override preventing roommates
# if 1 or more roommates on the team were manually placed, swap out all others. else swap out all but 1 randomly.
if ((length(roommate_set_manual) - length(roommate_set_no_manual)) != 0){
for (w in roommate_set_no_manual$acm_id){
swap1 <- w
# choose other school where no roommate conflict exists
schools_no_roommate = unique(team_placements_df$placement[team_placements_df$Roommate.Names != z])
school_ids <- 1:length(schools_no_roommate)
school_to_swap <- sample(school_ids[school_ids != y], 1)
# choose 1 ACM at other school who has no Manual.Placement
swap2 <- sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == school_to_swap ], 1)
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
} else {
acm_to_keep <- sample(roommate_set$acm_id, 1)
for (k in roommate_set$acm_id[roommate_set$acm_id != acm_to_keep]){
swap1 <- k
# choose other school where no roommate conflict exists
schools_no_roommate = unique(team_placements_df$placement[team_placements_df$Roommate.Names != z])
school_ids <- 1:length(schools_no_roommate)
school_to_swap <- sample(school_ids[school_ids != y], 1)
# choose 1 ACM at other school who has no Manual.Placement
swap2 <- sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == school_to_swap ], 1)
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
}
}
}
}
}
# We would like to ensure that high school students get placed in ES or MS
acms_for_swaps <- merge(team_placements_df[is.na(team_placements_df$Manual.Placement_id), ], school_targets, by.x = "placement", by.y = "sch_id", all.x = TRUE)
#print(acms_for_swaps)
hs_acms_to_swap <- acms_for_swaps[(acms_for_swaps$Ed_HS == 1) & (acms_for_swaps$span == "HS"),]
acms_to_swap_with <- acms_for_swaps[(acms_for_swaps$Ed_HS == 0) & (acms_for_swaps$span != "HS"),]
acms_to_swap_with <- acms_to_swap_with[sample(nrow(acms_to_swap_with), nrow(hs_acms_to_swap), replace=F), ]
team_placements_df[team_placements_df$acm_id %in% hs_acms_to_swap$acm_id, ]$placement = acms_to_swap_with$placement
team_placements_df[team_placements_df$acm_id %in% acms_to_swap_with$acm_id, ]$placement = hs_acms_to_swap$placement
return(team_placements_df)
}
team_placements_df <- initial_placement(acm_enc, school_targets, prevent_roommates = "No"")
team_placements_df
# Initial Team Placements
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
initial_placement <- function(acm_enc, school_targets, prevent_roommates){
# First place acm's at schools designated by Manual.Placement column
# NOTE: Removed seed parameter.  Seed is used for reproducability, but we want randomness in the start.
set.seed(42)
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_targets)){
team_slots = list(
# create a list that repeats each school 'id' for the size of each team
rep(x,
subset(school_targets$size, school_targets$sch_id == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- data.frame(placement=unlist(team_placements))
team_placements_df <- data.frame(placement=team_placements[sample(nrow(team_placements), replace=F), ],
acm_id= 1:nrow(team_placements))
# Merge team_placements_df with acm_df on the 'id' column
team_placements_df <- merge(acm_enc, team_placements_df, by = "acm_id", all.x = TRUE)
# Honor Manual Placements
sch_id_names <- school_df[, c("sch_id", "School Name")]
colnames(sch_id_names) <- c("Manual.Placement_id", "School.Name")
team_placements_df <- merge(team_placements_df, sch_id_names, by.x = "Manual.Placement", by.y = "School.Name", all.x = TRUE)
# Re-sort by acm_id and reset the index
team_placements_df <- team_placements_df[order(team_placements_df$acm_id), ]
rownames(team_placements_df) <- 1:nrow(team_placements_df)
acm_ids_with_Manual.Placement <- team_placements_df$acm_id[!is.na(team_placements_df$Manual.Placement_id)]
for (x in acm_ids_with_Manual.Placement){
acms_no_Manual.Placement <- team_placements_df[is.na(team_placements_df$Manual.Placement_id), ]
swap1 <- x
x_placement <- team_placements_df[team_placements_df$acm_id == x, ]$Manual.Placement_id
# Choose 1 acm_id to swap with at the school we want to ensure manual placement is honored
# What if already assigned to that school?
eligible_acm_ids_for_swap <- acms_no_Manual.Placement$acm_id[acms_no_Manual.Placement$placement == x_placement]
acm_id_to_swap <- sample( eligible_acm_ids_for_swap, 1 )
swap2 <- acm_id_to_swap
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
# Prevent Roommates from being on the same team
if (prevent_roommates == "Yes"){
# Check each team for roommates
for (y in 1:nrow(school_targets)){
school_frame = team_placements_df[team_placements_df$placement == y, ]
dup_roommates <- unique(school_frame$Roommate.Names[duplicated(school_frame$Roommate.Names)])
dup_roommates <- dup_roommates[!is.na(dup_roommates)]
if (length(dup_roommates) != 0){
# select df rows that contain any duplicated name
for (z in  dup_roommates){
roommate_set <- school_frame[which(school_frame$Roommate.Names == z), ]
roommate_set_manual <- roommate_set[!is.na(roommate_set$Manual.Placement_id), ]
roommate_set_no_manual <- roommate_set[is.na(roommate_set$Manual.Placement_id), ]
# manual placements will override preventing roommates
# if 1 or more roommates on the team were manually placed, swap out all others. else swap out all but 1 randomly.
if ((length(roommate_set_manual) - length(roommate_set_no_manual)) != 0){
for (w in roommate_set_no_manual$acm_id){
swap1 <- w
# choose other school where no roommate conflict exists
schools_no_roommate = unique(team_placements_df$placement[team_placements_df$Roommate.Names != z])
school_ids <- 1:length(schools_no_roommate)
school_to_swap <- sample(school_ids[school_ids != y], 1)
# choose 1 ACM at other school who has no Manual.Placement
swap2 <- sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == school_to_swap ], 1)
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
} else {
acm_to_keep <- sample(roommate_set$acm_id, 1)
for (k in roommate_set$acm_id[roommate_set$acm_id != acm_to_keep]){
swap1 <- k
# choose other school where no roommate conflict exists
schools_no_roommate = unique(team_placements_df$placement[team_placements_df$Roommate.Names != z])
school_ids <- 1:length(schools_no_roommate)
school_to_swap <- sample(school_ids[school_ids != y], 1)
# choose 1 ACM at other school who has no Manual.Placement
swap2 <- sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == school_to_swap ], 1)
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
}
}
}
}
}
# We would like to ensure that high school students get placed in ES or MS
acms_for_swaps <- merge(team_placements_df[is.na(team_placements_df$Manual.Placement_id), ], school_targets, by.x = "placement", by.y = "sch_id", all.x = TRUE)
#print(acms_for_swaps)
hs_acms_to_swap <- acms_for_swaps[(acms_for_swaps$Ed_HS == 1) & (acms_for_swaps$span == "HS"),]
acms_to_swap_with <- acms_for_swaps[(acms_for_swaps$Ed_HS == 0) & (acms_for_swaps$span != "HS"),]
acms_to_swap_with <- acms_to_swap_with[sample(nrow(acms_to_swap_with), nrow(hs_acms_to_swap), replace=F), ]
team_placements_df[team_placements_df$acm_id %in% hs_acms_to_swap$acm_id, ]$placement = acms_to_swap_with$placement
team_placements_df[team_placements_df$acm_id %in% acms_to_swap_with$acm_id, ]$placement = hs_acms_to_swap$placement
return(team_placements_df)
}
team_placements_df <- initial_placement(acm_enc, school_targets, prevent_roommates = "No")
team_placements_df
# Initial Team Placements
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
initial_placement <- function(acm_enc, school_targets, prevent_roommates){
# First place acm's at schools designated by Manual.Placement column
# NOTE: Removed seed parameter.  Seed is used for reproducability, but we want randomness in the start.
set.seed(42)
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_targets)){
team_slots = list(
# create a list that repeats each school 'id' for the size of each team
rep(x,
subset(school_targets$size, school_targets$sch_id == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- data.frame(placement=unlist(team_placements))
team_placements_df <- data.frame(placement=team_placements[sample(nrow(team_placements), replace=F), ],
acm_id= 1:nrow(team_placements))
# Merge team_placements_df with acm_df on the 'id' column
team_placements_df <- merge(acm_enc, team_placements_df, by = "acm_id", all.x = TRUE)
# Honor Manual Placements
sch_id_names <- school_df[, c("sch_id", "School Name")]
colnames(sch_id_names) <- c("Manual.Placement_id", "School.Name")
team_placements_df <- merge(team_placements_df, sch_id_names, by.x = "Manual.Placement", by.y = "School.Name", all.x = TRUE)
# Re-sort by acm_id and reset the index
team_placements_df <- team_placements_df[order(team_placements_df$acm_id), ]
rownames(team_placements_df) <- 1:nrow(team_placements_df)
acm_ids_with_Manual.Placement <- team_placements_df$acm_id[!is.na(team_placements_df$Manual.Placement_id)]
for (x in acm_ids_with_Manual.Placement){
acms_no_Manual.Placement <- team_placements_df[is.na(team_placements_df$Manual.Placement_id), ]
swap1 <- x
x_placement <- team_placements_df[team_placements_df$acm_id == x, ]$Manual.Placement_id
# Choose 1 acm_id to swap with at the school we want to ensure manual placement is honored
# What if already assigned to that school?
eligible_acm_ids_for_swap <- acms_no_Manual.Placement$acm_id[acms_no_Manual.Placement$placement == x_placement]
acm_id_to_swap <- sample( eligible_acm_ids_for_swap, 1 )
swap2 <- acm_id_to_swap
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
# Prevent Roommates from being on the same team
if (prevent_roommates == "Yes"){
# Check each team for roommates
for (y in 1:nrow(school_targets)){
school_frame = team_placements_df[team_placements_df$placement == y, ]
dup_roommates <- unique(school_frame$Roommate.Names[duplicated(school_frame$Roommate.Names)])
dup_roommates <- dup_roommates[!is.na(dup_roommates)]
if (length(dup_roommates) != 0){
# select df rows that contain any duplicated name
for (z in  dup_roommates){
roommate_set <- school_frame[which(school_frame$Roommate.Names == z), ]
roommate_set_manual <- roommate_set[!is.na(roommate_set$Manual.Placement_id), ]
roommate_set_no_manual <- roommate_set[is.na(roommate_set$Manual.Placement_id), ]
# manual placements will override preventing roommates
# if 1 or more roommates on the team were manually placed, swap out all others. else swap out all but 1 randomly.
if ((length(roommate_set_manual) - length(roommate_set_no_manual)) != 0){
for (w in roommate_set_no_manual$acm_id){
swap1 <- w
# choose other school where no roommate conflict exists
schools_no_roommate = unique(team_placements_df$placement[team_placements_df$Roommate.Names != z])
school_ids <- 1:length(schools_no_roommate)
school_to_swap <- sample(school_ids[school_ids != y], 1)
# choose 1 ACM at other school who has no Manual.Placement
swap2 <- sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == school_to_swap ], 1)
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
} else {
acm_to_keep <- sample(roommate_set$acm_id, 1)
for (k in roommate_set$acm_id[roommate_set$acm_id != acm_to_keep]){
swap1 <- k
# choose other school where no roommate conflict exists
schools_no_roommate = unique(team_placements_df$placement[team_placements_df$Roommate.Names != z])
school_ids <- 1:length(schools_no_roommate)
school_to_swap <- sample(school_ids[school_ids != y], 1)
# choose 1 ACM at other school who has no Manual.Placement
swap2 <- sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == school_to_swap ], 1)
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
}
}
}
}
}
# We would like to ensure that high school students get placed in ES or MS
acms_for_swaps <- merge(team_placements_df[is.na(team_placements_df$Manual.Placement_id), ], school_targets, by.x = "placement", by.y = "sch_id", all.x = TRUE)
#print(acms_for_swaps)
hs_acms_to_swap <- acms_for_swaps[(acms_for_swaps$Ed_HS == 1) & (acms_for_swaps$span == "HS"),]
acms_to_swap_with <- acms_for_swaps[(acms_for_swaps$Ed_HS == 0) & (acms_for_swaps$span != "HS"),]
acms_to_swap_with <- acms_to_swap_with[sample(nrow(acms_to_swap_with), nrow(hs_acms_to_swap), replace=F), ]
team_placements_df[team_placements_df$acm_id %in% hs_acms_to_swap$acm_id, ]$placement = acms_to_swap_with$placement
team_placements_df[team_placements_df$acm_id %in% acms_to_swap_with$acm_id, ]$placement = hs_acms_to_swap$placement
return(team_placements_df)
}
team_placements_df <- initial_placement(acm_enc, school_targets, prevent_roommates = "Yes")
team_placements_df
# Initial Team Placements
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
initial_placement <- function(acm_enc, school_targets, prevent_roommates){
# First place acm's at schools designated by Manual.Placement column
# NOTE: Removed seed parameter.  Seed is used for reproducability, but we want randomness in the start.
set.seed(42)
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_targets)){
team_slots = list(
# create a list that repeats each school 'id' for the size of each team
rep(x,
subset(school_targets$size, school_targets$sch_id == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- data.frame(placement=unlist(team_placements))
team_placements_df <- data.frame(placement=team_placements[sample(nrow(team_placements), replace=F), ],
acm_id= 1:nrow(team_placements))
# Merge team_placements_df with acm_df on the 'id' column
team_placements_df <- merge(acm_enc, team_placements_df, by = "acm_id", all.x = TRUE)
# Honor Manual Placements
sch_id_names <- school_df[, c("sch_id", "School Name")]
colnames(sch_id_names) <- c("Manual.Placement_id", "School.Name")
team_placements_df <- merge(team_placements_df, sch_id_names, by.x = "Manual.Placement", by.y = "School.Name", all.x = TRUE)
# Re-sort by acm_id and reset the index
team_placements_df <- team_placements_df[order(team_placements_df$acm_id), ]
rownames(team_placements_df) <- 1:nrow(team_placements_df)
acm_ids_with_Manual.Placement <- team_placements_df$acm_id[!is.na(team_placements_df$Manual.Placement_id)]
for (x in acm_ids_with_Manual.Placement){
acms_no_Manual.Placement <- team_placements_df[is.na(team_placements_df$Manual.Placement_id), ]
swap1 <- x
x_placement <- team_placements_df[team_placements_df$acm_id == x, ]$Manual.Placement_id
# Choose 1 acm_id to swap with at the school we want to ensure manual placement is honored
# What if already assigned to that school?
eligible_acm_ids_for_swap <- acms_no_Manual.Placement$acm_id[acms_no_Manual.Placement$placement == x_placement]
acm_id_to_swap <- sample( eligible_acm_ids_for_swap, 1 )
swap2 <- acm_id_to_swap
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
# Prevent Roommates from being on the same team
if (prevent_roommates == "Yes"){
# Check each team for roommates
for (y in 1:nrow(school_targets)){
school_frame = team_placements_df[team_placements_df$placement == y, ]
dup_roommates <- unique(school_frame$Roommate.Names[duplicated(school_frame$Roommate.Names)])
dup_roommates <- dup_roommates[!is.na(dup_roommates)]
if (length(dup_roommates) != 0){
# select df rows that contain any duplicated name
print(school_frame)
for (z in  dup_roommates){
roommate_set <- school_frame[which(school_frame$Roommate.Names == z), ]
roommate_set_manual <- roommate_set[!is.na(roommate_set$Manual.Placement_id), ]
roommate_set_no_manual <- roommate_set[is.na(roommate_set$Manual.Placement_id), ]
# manual placements will override preventing roommates
# if 1 or more roommates on the team were manually placed, swap out all others. else swap out all but 1 randomly.
if ((length(roommate_set_manual) - length(roommate_set_no_manual)) != 0){
for (w in roommate_set_no_manual$acm_id){
swap1 <- w
# choose other school where no roommate conflict exists
schools_no_roommate = unique(team_placements_df$placement[team_placements_df$Roommate.Names != z])
school_ids <- 1:length(schools_no_roommate)
school_to_swap <- sample(school_ids[school_ids != y], 1)
# choose 1 ACM at other school who has no Manual.Placement
swap2 <- sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == school_to_swap ], 1)
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
} else {
acm_to_keep <- sample(roommate_set$acm_id, 1)
for (k in roommate_set$acm_id[roommate_set$acm_id != acm_to_keep]){
swap1 <- k
# choose other school where no roommate conflict exists
schools_no_roommate = unique(team_placements_df$placement[team_placements_df$Roommate.Names != z])
school_ids <- 1:length(schools_no_roommate)
school_to_swap <- sample(school_ids[school_ids != y], 1)
# choose 1 ACM at other school who has no Manual.Placement
swap2 <- sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == school_to_swap ], 1)
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
}
}
}
}
}
# We would like to ensure that high school students get placed in ES or MS
acms_for_swaps <- merge(team_placements_df[is.na(team_placements_df$Manual.Placement_id), ], school_targets, by.x = "placement", by.y = "sch_id", all.x = TRUE)
#print(acms_for_swaps)
hs_acms_to_swap <- acms_for_swaps[(acms_for_swaps$Ed_HS == 1) & (acms_for_swaps$span == "HS"),]
acms_to_swap_with <- acms_for_swaps[(acms_for_swaps$Ed_HS == 0) & (acms_for_swaps$span != "HS"),]
acms_to_swap_with <- acms_to_swap_with[sample(nrow(acms_to_swap_with), nrow(hs_acms_to_swap), replace=F), ]
team_placements_df[team_placements_df$acm_id %in% hs_acms_to_swap$acm_id, ]$placement = acms_to_swap_with$placement
team_placements_df[team_placements_df$acm_id %in% acms_to_swap_with$acm_id, ]$placement = hs_acms_to_swap$placement
return(team_placements_df)
}
team_placements_df <- initial_placement(acm_enc, school_targets, prevent_roommates = "Yes")
team_placements_df
# Initial Team Placements
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
initial_placement <- function(acm_enc, school_targets, prevent_roommates){
# First place acm's at schools designated by Manual.Placement column
# NOTE: Removed seed parameter.  Seed is used for reproducability, but we want randomness in the start.
set.seed(42)
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_targets)){
team_slots = list(
# create a list that repeats each school 'id' for the size of each team
rep(x,
subset(school_targets$size, school_targets$sch_id == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- data.frame(placement=unlist(team_placements))
team_placements_df <- data.frame(placement=team_placements[sample(nrow(team_placements), replace=F), ],
acm_id= 1:nrow(team_placements))
# Merge team_placements_df with acm_df on the 'id' column
team_placements_df <- merge(acm_enc, team_placements_df, by = "acm_id", all.x = TRUE)
# Honor Manual Placements
sch_id_names <- school_df[, c("sch_id", "School Name")]
colnames(sch_id_names) <- c("Manual.Placement_id", "School.Name")
team_placements_df <- merge(team_placements_df, sch_id_names, by.x = "Manual.Placement", by.y = "School.Name", all.x = TRUE)
# Re-sort by acm_id and reset the index
team_placements_df <- team_placements_df[order(team_placements_df$acm_id), ]
rownames(team_placements_df) <- 1:nrow(team_placements_df)
acm_ids_with_Manual.Placement <- team_placements_df$acm_id[!is.na(team_placements_df$Manual.Placement_id)]
for (x in acm_ids_with_Manual.Placement){
acms_no_Manual.Placement <- team_placements_df[is.na(team_placements_df$Manual.Placement_id), ]
swap1 <- x
x_placement <- team_placements_df[team_placements_df$acm_id == x, ]$Manual.Placement_id
# Choose 1 acm_id to swap with at the school we want to ensure manual placement is honored
# What if already assigned to that school?
eligible_acm_ids_for_swap <- acms_no_Manual.Placement$acm_id[acms_no_Manual.Placement$placement == x_placement]
acm_id_to_swap <- sample( eligible_acm_ids_for_swap, 1 )
swap2 <- acm_id_to_swap
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
# Prevent Roommates from being on the same team
if (prevent_roommates == "Yes"){
# Check each team for roommates
for (y in 1:nrow(school_targets)){
school_frame = team_placements_df[team_placements_df$placement == y, ]
dup_roommates <- unique(school_frame$Roommate.Names[duplicated(school_frame$Roommate.Names)])
dup_roommates <- dup_roommates[!is.na(dup_roommates)]
if (length(dup_roommates) != 0){
# select df rows that contain any duplicated name
print(school_frame)
for (z in  dup_roommates){
roommate_set <- school_frame[which(school_frame$Roommate.Names == z), ]
roommate_set_manual <- roommate_set[!is.na(roommate_set$Manual.Placement_id), ]
roommate_set_no_manual <- roommate_set[is.na(roommate_set$Manual.Placement_id), ]
# manual placements will override preventing roommates
# if 1 or more roommates on the team were manually placed, swap out all others. else swap out all but 1 randomly.
if ((length(roommate_set_manual) - length(roommate_set_no_manual)) != 0){
for (w in roommate_set_no_manual$acm_id){
swap1 <- w
# choose other school where no roommate conflict exists
schools_no_roommate = unique(team_placements_df$placement[team_placements_df$Roommate.Names != z])
school_ids <- 1:length(schools_no_roommate)
school_to_swap <- sample(school_ids[school_ids != y], 1)
# choose 1 ACM at other school who has no Manual.Placement
swap2 <- sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == school_to_swap ], 1)
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
} else {
acm_to_keep <- sample(roommate_set$acm_id, 1)
for (k in roommate_set$acm_id[roommate_set$acm_id != acm_to_keep]){
swap1 <- k
# choose other school where no roommate conflict exists
schools_no_roommate = unique(team_placements_df$placement[team_placements_df$Roommate.Names != z])
school_ids <- 1:length(schools_no_roommate)
school_to_swap <- sample(school_ids[school_ids != y], 1)
# choose 1 ACM at other school who has no Manual.Placement
swap2 <- sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == school_to_swap ], 1)
# Swap the team placement of those 2 ACMs
team_placements_df$placement <- replace(team_placements_df$placement, c(swap1, swap2), team_placements_df$placement[c(swap2, swap1)])
}
}
}
}
}
}
# We would like to ensure that high school students get placed in ES or MS
acms_for_swaps <- merge(team_placements_df[is.na(team_placements_df$Manual.Placement_id), ], school_targets, by.x = "placement", by.y = "sch_id", all.x = TRUE)
#print(acms_for_swaps)
hs_acms_to_swap <- acms_for_swaps[(acms_for_swaps$Ed_HS == 1) & (acms_for_swaps$span == "HS"),]
acms_to_swap_with <- acms_for_swaps[(acms_for_swaps$Ed_HS == 0) & (acms_for_swaps$span != "HS"),]
acms_to_swap_with <- acms_to_swap_with[sample(nrow(acms_to_swap_with), nrow(hs_acms_to_swap), replace=F), ]
team_placements_df[team_placements_df$acm_id %in% hs_acms_to_swap$acm_id, ]$placement = acms_to_swap_with$placement
team_placements_df[team_placements_df$acm_id %in% acms_to_swap_with$acm_id, ]$placement = hs_acms_to_swap$placement
return(team_placements_df)
}
team_placements_df <- initial_placement(acm_enc, school_targets, prevent_roommates = "No")
team_placements_df
