corps_demos <- corps_demographic_targets(school_df, acm_enc)
# Unravel list into some variables.  Mostly so that the code is a little cleaner later.
education <- corps_demos$education
lang <- corps_demos$lang
tut_exp <- corps_demos$tut_exp
math <- corps_demos$math
gender <- corps_demos$gender
school.data <- select(school_df, `sch_id`, School, `Team Size`, GradeLevel, `% Hispanic`, Address, `Geographic Neighborhood`) %>%
rename(size = `Team Size`,
span = GradeLevel,
nhood = `Geographic Neighborhood`) %>%
mutate(size = as.numeric(size),
HSGrad_tgt = ifelse(span=="High", 0, education[education$level %in% 'HS',]$'ratio' * size),
SomeCol_tgt = education[education$level %in% 'SomeCol',]$'ratio' * as.numeric(size),
TutExp = as.numeric(size) * tut_exp[tut_exp$HasTutored == 1,]$'ratio',
SpanishNeed = pmax(spanishNeed(`% Hispanic`), 1),# This sets a minimum of 1 spanish speaker per team.  This might make sense in LA, but not other places.
OtherLang_tgt = lang[lang$ability %in% 'other',]$'ratio' * as.numeric(size),
Math_tgt = ifelse(span=="Elementary", as.numeric(size)*.5*math, ifelse(span=="Middle", .75*as.numeric(size)*math, as.numeric(size)*math)),
Male_tgt = as.numeric(size)*gender,
AA_tgt = ifelse(nhood == "W", 1, 0))
}
# Initial Team Placements
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
initial_placement <- function(acm_enc, school_targets){
# First place acm's at schools designated by Manual.Placement column
# NOTE: Removed seed parameter.  Seed is used for reproducability, but we want randomness in the start.
# first create an empty list
team_placements = list()
acms_with_Manual.Placement <- acm_enc %>%
left_join(., select(school_targets, sch_id:School),
by=c("Manual.Placement" = "School")) %>%
filter(!is.na(sch_id))
filled_slot_counts <- acms_with_Manual.Placement %>%
group_by(sch_id) %>%
summarise(filled = n())
team_size_targets <- select(school_targets, sch_id:size) %>%
left_join(., filled_slot_counts, by=("sch_id")) %>%
replace_na(list(filled = 0)) %>%
mutate(unfilled_slots = as.numeric(size) - as.numeric(filled))
# use a for-loop to read each team size
for (x in team_size_targets$sch_id){
team_slots = list(
# create a list that repeats each school 'id' for the size of each team
rep(x,
subset(team_size_targets$unfilled_slots, team_size_targets$sch_id == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- data.frame(placement=unlist(team_placements))
slots <- nrow(team_placements)
filled_acm_roster <- c(acm_enc[is.na(acm_enc$Manual.Placement), ]$acm_id, 9000:(9000 + slots - nrow(acm_enc[is.na(acm_enc$Manual.Placement), ]) - 1))
# Randomize Starting Place
team_placements_df <- data.frame(sch_id=team_placements[sample(nrow(team_placements), replace=F), ],
acm_id= filled_acm_roster) %>%
union(., select(acms_with_Manual.Placement, sch_id, acm_id)) %>%
rename(placement = sch_id)
# Merge team_placements_df with acm_df on the 'id' column
team_placements_df <- left_join(team_placements_df, acm_enc, by = "acm_id") %>%
replace_na(replace = list(Math.Confidence = 0, Ed_HS = 0, Ed_SomeCol = 0, Ed_Col = 0,
HasTutored = 0, SpanishAble = 0, Lang_Other = 0, Male = 0,
Other.Gender =0, Race.Ethnicity.Hispanic = 0,
Race.Ethnicity.Asian = 0, Race.Ethnicity.White = 0,
Race.Ethnicity.Black = 0, days_old = 0))
# Honor Manual Placements
sch_id_names <- school_df[, c("sch_id", "School")]
colnames(sch_id_names) <- c("Manual.Placement_id", "School.Name")
team_placements_df <- merge(team_placements_df, sch_id_names, by.x = "Manual.Placement", by.y = "School.Name", all.x = TRUE)
# We would like to ensure that high school students get placed in ES or MS
acms_for_swaps <- merge(team_placements_df[is.na(team_placements_df$Manual.Placement_id), ], school_targets, by.x = "placement", by.y = "sch_id", all.x = TRUE)
#print(acms_for_swaps)
hs_acms_to_swap <- acms_for_swaps[(acms_for_swaps$Ed_HS == 1) & (acms_for_swaps$span == "High"),]
acms_to_swap_with <- acms_for_swaps[(acms_for_swaps$Ed_HS == 0) & (acms_for_swaps$span != "High"),]
acms_to_swap_with <- acms_to_swap_with[sample(nrow(acms_to_swap_with), nrow(hs_acms_to_swap), replace=F), ]
team_placements_df[team_placements_df$acm_id %in% hs_acms_to_swap$acm_id, ]$placement <- acms_to_swap_with$placement
team_placements_df[team_placements_df$acm_id %in% acms_to_swap_with$acm_id, ]$placement <- hs_acms_to_swap$placement
return(team_placements_df)
}
# Calculate score
hs_loss <- function(targets, actuals){
loss <- ifelse(targets == 0, (targets - actuals) * -1e10, (targets - actuals)^2)
sum(loss)
}
reqd_spanish_loss <- function(targets, actuals, min_reqd = 1){
loss <- ifelse(actuals < min_reqd, 1e10, (targets - actuals)^2)
sum(loss)
}
reqd_males <- function(targets, actuals, min_reqd = 1){
loss <- ifelse(actuals < min_reqd, 1e10, (targets - actuals)^2)
sum(loss)
}
reqd_AA <- function(targets, actuals, min_reqd = 1){
loss <- ifelse(targets == 1 & actuals == 0, 1e10, 0)
sum(loss)
}
calculate_score = function(team_placements_df, school_targets, gender_target=gender_g) {
#team_placements_df <- bestPlacement$best_placements %>% filter(acm_id < 9000)
# Merge  with school_df to pull in school characteristics
team_placements_df <- team_placements_df %>%
left_join(., school_targets, by=c("placement" = "sch_id")) %>%
filter(acm_id < 9000)
# Store each score in a list
scores = list()
# This score is simply the sum number of seconds each ACM travels to their assigned school
commutes = team_placements_df %>%
mutate(acm_dest_id = paste(acm_id, "-", placement)) %>%
left_join(., acm_commutes, by="acm_dest_id") %>%
.[!is.na(.$time), ]
# Take the sqrt to scale the value closer to the other features
scores$commute_score <- mean(commutes$time)
# This score is the difference between the [overall age variance across the corps] and [overall average of each team's average age variance]
age_var <- team_placements_df %>%
group_by(placement) %>%
summarize(age_var = var(days_old)) %>%
filter(!is.na(age_var)) %>%
ungroup() %>%
summarize(avg_age_var = mean(age_var))
scores$age_score <- sqrt(abs(age_var$avg_age_var - var(team_placements_df$days_old)))
# This score is the overall average of each team's average % representation that each teammate experiences. For example, 0.44 means that for the average team, the average teammate experiences that his/her personal ethnicity is represented in 44% of the team.
ethnicity_eths <-
team_placements_df %>%
group_by(placement,
Race.Ethnicity.Black,
Race.Ethnicity.White,
Race.Ethnicity.Asian,
Race.Ethnicity.Hispanic) %>%
dplyr::summarize(n_eths = n()) %>%
group_by(placement) %>%
dplyr::mutate(pct_eths = n_eths/sum(n_eths) * n_eths / sum(n_eths)) %>%
dplyr::mutate(avg_eths_rep = sum(pct_eths)) %>%
summarize(avg_eths_rep = mean(avg_eths_rep)) %>%
summarize(avg_eths_rep = mean(avg_eths_rep))
scores$ethnicity_score <- (ethnicity_eths$avg_eths_rep*1000)
placed <- team_placements_df %>%
group_by(placement) %>%
summarise(HS_Grads = sum(Ed_HS),
SomeCol = sum(Ed_SomeCol),
Tutoring = sum(HasTutored),
Spanish = sum(SpanishAble),
OtherLang = sum(Lang_Other),
MathAble = sum(Math.Confidence),
Males = sum(Male),
AAs = sum(Race.Ethnicity.Black)) %>%
left_join(., school_targets, by=c("placement" = "sch_id"))
scores$Edscore <- hs_loss(placed$HSGrad_tgt, placed$HS_Grads) + sum((placed$SomeCol_tgt - placed$SomeCol)^2)
scores$Tutoring <- sum((placed$TutExp - placed$Tutoring)^2)
scores$Spanish <- (reqd_spanish_loss(placed$SpanishNeed, placed$Spanish, min_reqd = 1) + sum((placed$OtherLang_tgt - placed$OtherLang)^2))
scores$Math <- sum((placed$Math_tgt - placed$MathAble)^2)
scores$Gender <- reqd_males(placed$Male_tgt, placed$Males, 1)
scores$AA <- reqd_AA(placed$AA_tgt, placed$AAs)
scores$aggr_score <- sum(unlist(scores))
return(scores)
}
# Temperature Function
current_temperature = function(iter, s_curve_amplitude, s_curve_center, s_curve_width) {
s_curve_amplitude * s_curve(iter, s_curve_center, s_curve_width)
}
s_curve = function(x, center, width) {
1 / (1 + exp((x - center) / width))
}
# Annealing and Swap Function
run_intermediate_annealing_process = function(starting_placements, school_df, best_placements=starting_placements, best_score=1e12, starting_iteration=1, number_of_iterations, center_scale=0.1, width_scale=0.1) {
# starting_placements = team_placements_df
# school_df = school_targets
# best_placements = team_placements_df
# best_score = 142078800000
# starting_iteration = 1
# number_of_iterations = 10000
# center_scale = 0.1
# width_scale = 0.1
team_placements_df <- starting_placements
placement_score <- calculate_score(team_placements_df, school_df)$aggr_score
trace <- data.frame(iter=c(1:number_of_iterations), score=0, temp=0, ratio=0)
trace[1, 2] <- placement_score
for(i in 1:number_of_iterations) {
i <- 1
iter = starting_iteration + i
temp = current_temperature(iter, 3000, number_of_iterations * center_scale, number_of_iterations * width_scale)
candidate_placements_df <- team_placements_df
acms_no_Manual.Placement <- subset(candidate_placements_df, (is.na(candidate_placements_df$Manual.Placement)))
# Choose 2 schools at random
# We need to ensure that those schools aren't fully placed
schools_to_swap = sample(unique(acms_no_Manual.Placement$placement), 2)
# Choose 1 ACM from each of those schools. Select only ACMs who have no Manual.Placement
swap1 = as.numeric(sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == schools_to_swap[1] ], 1))
swap2 = as.numeric(sample(acms_no_Manual.Placement$acm_id[ acms_no_Manual.Placement$placement == schools_to_swap[2] ], 1))
#print(c(swap1, swap2))
swap_school_1 = acms_no_Manual.Placement$placement[acms_no_Manual.Placement$acm_id == swap1]
swap_school_2 = acms_no_Manual.Placement$placement[acms_no_Manual.Placement$acm_id == swap2]
#print(c(swap_school_1, swap_school_2))
# Swap the team assignment of those 2 ACMs - NOTE this is done by index, but we use acm_id as index
candidate_placements_df$placement[candidate_placements_df$acm_id == swap1] <- swap_school_2
candidate_placements_df$placement[candidate_placements_df$acm_id == swap2] <- swap_school_1
candidate_score = calculate_score(candidate_placements_df, school_df)
trace[i+1, 2] <- candidate_score$aggr_score
# Current implamentation of temperature never hits zero.
if (temp > 0) {
ratio = exp((placement_score - candidate_score$aggr_score) / temp)
} else {
ratio = as.numeric(candidate_score$aggr_score < placement_score)
}
trace[i+1, 3] <- temp
trace[i+1, 4] <- ratio
if (runif(1) < ratio) {
team_placements_df = candidate_placements_df
placement_score = candidate_score$aggr_score
all_scores = candidate_score
if (placement_score < best_score) {
best_placements = team_placements_df
best_score = placement_score
best_score_diff = all_scores
}
}
}
# Merge in School characteristics
best_placements <- merge(best_placements, school_df, by.x = "placement", by.y = "sch_id", all.x = TRUE)
best_placements <- best_placements[order(best_placements$placement),]
return(list(best_placements=best_placements,
best_score=best_score,
diff_scores=best_score_diff,
trace=trace))
}
# Visualize Error Over Time
traceplot <- function(trace){
library(ggplot2)
ggplot(data = trace, aes(x = iter, y = score)) +
geom_point() +
coord_cartesian(ylim = c(1e9, 1e11))
}
tempplot <- function(trace){
library(ggplot2)
ggplot(data = trace, aes(x = iter)) +
geom_point(aes(y=ratio)) +
geom_line(aes(y=temp)) +
coord_cartesian(ylim = c(0, 2800))
}
library(ggplot2)
plot_curve <- function(iters){
# Derived these ratios based on the desired shape of the graph.
# Traits that were desirable were about 50% being highly volotile and the other half not.
# Wants to give it enough to to be conservative as well.
data <- data.frame(x = 1:iters, y = current_temperature(1:iters, 1000, iters * .1, iters * .05))
ggplot(data, aes(x, y)) +
geom_line()
}
#plot_curve(10000)
# Full Application
library(readxl)
library(dplyr)
library(tidyr)
#root_dir = "C:\\Users\\perus\\OneDrive\\Documents\\GitHub\\ACM-School-Placement\\"
root_dir = "C:\\Users\\aperusse\\GitHub\\ACM-School-Placement\\"
acm_df <- read_excel(path = paste(root_dir, "Input 1 - LA ACM Data.xlsx", sep = ""), col_types = c("text", "text", "text", "text","text","text","date", "numeric", "text","text","numeric", "text","text","text"))
# This part not necessary in PowerBI, since dates are read in as %m/%d/%Y already
acm_df$Birth.Date <- format(as.Date(acm_df$Birth.Date), "%m/%d/%Y")
acm_enc <- encode_acm_df(acm_df)
school_df <- read_excel(path = paste(root_dir, "Input 3 - LA School Data.xlsx", sep = ""),
col_types = c("numeric", "text", "numeric", "text", "numeric", "text", "text"))
acm_commutes <- read.csv(paste(root_dir, "Input 2 - LA ACM Commutes.csv", sep = ""),
col.names = c("or", "de", "time", "acm_id", "sch_id")) %>%
mutate(acm_dest_id = paste(acm_id, "-", sch_id),
time = time/60)
# Precalculate school targets
school_targets <- school_config(school_df, acm_enc)
placement <- function(acm_enc, school_targets, number_iterations, center_scale, width_scale) {
team_placements_df <- initial_placement(acm_enc, school_targets)
#validity <- left_join(team_placements_df, school_targets, by=c("placement" = "sch_id"))
output <- run_intermediate_annealing_process(starting_placements = team_placements_df, school_df = school_targets, best_placements = team_placements_df, best_score = 1e12, starting_iteration = 1, number_of_iterations = number_iterations, center_scale=center_scale, width_scale=width_scale)
}
# best_placements <- output$best_placements
#
# # Playing around with methods to get more info in the output. It's probably better to just re-calculate these in visualizations...
# best_placements$best_score <- output$best_score
# best_placements$ethnicity_score <- output$diff_scores$ethnicity_score
# best_placements$commute_score <- output$diff_scores$commute_score
#
# diff_scores <- output$diff_scores
#
# trace <- output$trace
Single_Run <- placement(acm_enc, school_targets, 1000, center_scale=runif(1, 1e-3, 0.25), width_scale=runif(1, 1e-3, 0.25))
Single_Run$diff_scores
validate <- aggregate_features(Single_Run$best_placements)
View(validate)
library(doSNOW)
library(foreach)
library(gridExtra)
n_processors = 8
cl <- makeCluster(n_processors)
registerDoSNOW(cl)
n_runs = 4*n_processors
n_iters = 50000
Runs <- foreach(i=1:n_runs) %dopar% {
library(dplyr)
library(tidyr)
#print(system.time(placement(acm_enc, school_targets, 25000)))
placement(acm_enc, school_targets, n_iters, center_scale=runif(1, 1e-3, 0.15), width_scale=runif(1, 1e-3, 0.2))
}
stopCluster(cl)
best_run <- which.min(sapply(Runs, "[", i=2))
ax <- traceplot(Runs[[best_run]]$trace)
bx <- tempplot(Runs[[best_run]]$trace)
plot(grid.arrange(ax, bx, ncol=2))
#print(Runs[[i]]$diff_scores)
bestPlacement <- Runs[[best_run]]
aggregate_features <- function(df){
validate_placement <- df %>%
mutate(acm_dest_id = paste(acm_id, "-", placement)) %>%
left_join(., acm_commutes, by="acm_dest_id") %>%
replace_na(replace = list("time" = 0)) %>%
group_by(School, placement) %>%
summarise(HS_Grads = sum(Ed_HS),
SomeCol = sum(Ed_SomeCol),
Tutoring = sum(HasTutored),
Spanish = sum(SpanishAble),
OtherLang = sum(Lang_Other),
MathAble = sum(Math.Confidence),
Males = sum(Male),
Gender.Other = sum(Other.Gender),
Hispanic.Latino = sum(Race.Ethnicity.Hispanic),
Asian.PI = sum(Race.Ethnicity.Asian),
White = sum(Race.Ethnicity.White),
Black = sum(Race.Ethnicity.Black),
AvgCommute = mean(time))
}
validate <- aggregate_features(Single_Run$best_placements)
#write.csv(bestPlacement$best_placements, file = "outputs/acm_placements.csv")
#write.csv(school_targets, file="outputs/school_targets.csv")
#write.csv(placements_and_commute, file="outputs/placements_with_commutes.csv")
bestPlacement$best_placements
View(bestPlacement$best_placements)
validate <- aggregate_features(bestPlacement$best_placements)
View(validate)
bestPlacement$diff_scores
bestPlacement$trace
View(bestPlacement$trace)
placement_score <- calculate_score(team_placements_df, school_df)$aggr_score
team_placements_df <- initial_placement(acm_enc, school_targets)
placement_score <- calculate_score(team_placements_df, school_df)$aggr_score
school_df = school_targets
placement_score <- calculate_score(team_placements_df, school_df)$aggr_score
trace <- data.frame(iter=c(1:number_of_iterations), score=0, temp=0, ratio=0)
starting_iteration = 10000
trace <- data.frame(iter=c(1:number_of_iterations), score=0, temp=0, ratio=0)
trace[1, 2] <- placement_score
trace <- data.frame(iter=c(1:number_of_iterations), score=0, temp=0, ratio=0)
number_of_iterations = 10000
trace <- data.frame(iter=c(1:number_of_iterations), score=0, temp=0, ratio=0)
View(trace)
trace[1, 2] <- placement_score
placements_and_commute <- bestPlacement$best_placements %>%
mutate(acm_dest_id = paste(acm_id, "-", placement)) %>%
left_join(., select(acm_commutes, acm_dest_id, time), by="acm_dest_id") %>%
replace_na(replace = list("time" = 0))
school_totals_and_targets <- aggregate_features(placement) %>%
left_join(., select(school_targets, -School), by=c("placement" = "sch_id"))
school_totals_and_targets <- aggregate_features(bestPlacement$best_placements) %>%
left_join(., select(school_targets, -School), by=c("placement" = "sch_id"))
write.csv(placements_and_commute, file="outputs/acm_Placements.csv")
validation <- list()
for (i in c(1:32)){
validation[i] <- aggregate_features(Runs[i]$best_placements)
}
validate <- aggregate_features(bestPlacement$best_placements)
Runs[1]
Runs[[1]]
Runs[[4]]
Runs[[2]]
Runs[[2]]$best_placements
Runs[[0]]$best_placements
Runs[[1]]$best_placements
View(Runs[[1]]$best_placements)
for (i in c(1:32)){
validation[i] <- aggregate_features(Runs[[i]]$best_placements)
}
validation
View(validation[1])
View(validation[[1]])
for (i in c(1:32)){
validation[i] <- aggregate_features(Runs[i]$best_placements)
}
validation <- list()
Runs[[1]]
Runs[[1]]$best_placements
for (i in c(1:32)){
validation[[i]] <- aggregate_features(Runs[i]$best_placements)
}
for (i in c(1:32)){
validation[[i]] <- aggregate_features(Runs[[i]]$best_placements)
}
View(validation[[1]])
View(validation[[2]])
View(validation[[3]])
View(validation[[4]])
View(validation[[5]])
View(validation[[6]])
View(validation[[7]])
View(validation[[7]])
View(validation[[8]])
View(validation[[9]])
View(validation[[10]])
View(validation[[11]])
View(validation[[12]])
View(validation[[13]])
View(validation[[14]])
View(validation[[15]])
View(validation[[16]])
View(validation[[17]])
Runs[[17]]$diff_scores
unlist(Runs[[17]]$diff_scores)
?sapply
Runs[[2]]
Runs[[1]]
Runs[[1]]$diff_scores
Runs[1]
Runs[2]
Runs[3]
Runs[4]
sapply(Runs,function(x) x[2])
sapply(Runs,function(x) x[1])
sapply(Runs,function(x) x[3])
sapply(Runs,function(x) unlist(x[3]))
diff_scores <- sapply(Runs,function(x) unlist(x[3]))
diff_scores <- data.frame(sapply(Runs,function(x) unlist(x[3])))
View(diff_scores)
?data.frame
diff_scores <- sapply(Runs,function(x) unlist(x[3]))
rgind(diff_scores)
rbind(diff_scores)
cbind(diff_scores)
data.frame(cbind(diff_scores))
View(data.frame(cbind(diff_scores)))
View(data.frame(rbind(diff_scores)))
View(data.frame(t(rbind(diff_scores))))
diff_scores <- t(sapply(Runs,function(x) unlist(x[3])))
diff_scores <- data.frame(t(sapply(Runs,function(x) unlist(x[3]))))
View(diff_scores)
write.csv(diff_scores, file="outputs/diff_scores.csv")
diff_scores <- data.frame(t(sapply(Runs,function(x) unlist(x[3])))) %>%
.$run <- 1:32
diff_scores <- data.frame(t(sapply(Runs,function(x) unlist(x[3])))) %>%
.$run = 1:32
diff_scores$id <- c(1:length(Runs))
View(diff_scores)
?gather
tidy_scores <- gather(diff_scores, "id", 1:10)
tidy_scores <- gather(diff_scores, 1:10)
tidy_scores <- gather(diff_scores, feature, score, 1:10)
View(tidy_scores)
validation <- list()
for (i in c(1:32)){
validation[[i]] <- aggregate_features(Runs[[i]]$best_placements)
}
?geom_bar
library(ggplot2)
ggplot(tidy_scores) +
geom_bar(aes(score), colour = id)
ggplot(tidy_scores) +
geom_bar(aes(score))
ggplot(tidy_scores, aes(score)) +
geom_bar(color = feature)
ggplot(tidy_scores, aes(score)) +
geom_bar(color = tidy_score$feature)
ggplot(tidy_scores, aes(score)) +
geom_bar(color = tidy_scores$feature)
ggplot(tidy_scores, aes(score)) +
geom_bar(color = tidy_scores$id)
tidy_scores$feature <- factor(tidy_scores$feature)
ggplot(tidy_scores, aes(score)) +
geom_bar(color = tidy_scores$feature)
ggplot(tidy_scores, aes(score, fill=feature)) + geom_bar()
ggplot(tidy_scores, aes(score)) +
geom_bar() +
facet_grid(~ feature)
ggplot(tidy_scores, aes(score)) +
geom_point() +
facet_grid(~ feature)
ggplot(tidy_scores, aes(x=run, y=score)) +
geom_point() +
facet_grid(~ feature)
ggplot(tidy_scores, aes(x=id, y=score)) +
geom_point() +
facet_grid(~ feature)
unique(tidy_scores$feature)
ggplot(select(tidy_scores, -diff_scores.aggr_score, -diff_scores.Spanish), aes(x=id, y=score)) +
geom_point() +
facet_grid(~ feature)
ggplot(select(tidy_scores, -diff_scores.aggr_score, -diff_scores.Spanish), aes(x=id, y=score)) +
geom_point() +
facet_grid(~ feature)
select(tidy_scores, -diff_scores.aggr_score, -diff_scores.Spanish)
ggplot(filter(tidy_scores, feature != diff_scores.aggr_score, feature != diff_scores.Spanish), aes(x=id, y=score)) +
geom_point() +
facet_grid(~ feature)
ggplot(filter(tidy_scores, feature != "diff_scores.aggr_score", feature != "diff_scores.Spanish"), aes(x=id, y=score)) +
geom_point() +
facet_grid(~ feature)
View(tidy_scores)
View(Runs[[15]]$best_placements)
View(validate)
View(validation[[25]])
bestPlacement <- Runs[[25]]
placements_and_commute <- bestPlacement$best_placements %>%
mutate(acm_dest_id = paste(acm_id, "-", placement)) %>%
left_join(., select(acm_commutes, acm_dest_id, time), by="acm_dest_id") %>%
replace_na(replace = list("time" = 0))
write.csv(placements_and_commute, file="outputs/acm_Placements.csv")
Runs[[25]]$best_placements
View(Runs[[25]]$best_placements)
ggplot(filter(tidy_scores, feature != "diff_scores.aggr_score", feature != "diff_scores.Spanish"), aes(x=id, y=score)) +
geom_point() +
facet_grid(~ feature)
Runs[[25]]$diff_scores
