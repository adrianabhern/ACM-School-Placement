within(id_dest <- paste(id, dest, sep = "_"))
# Merge team_placements_df with acm_df on the 'id' column we just created
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
# Merge acm_df_with_placements with school_df to pull in school characteristics
acm_df_with_placements <- merge(acm_df_with_placements, school_df, by.x = "Team.Placement", by.y = "id", all.x = TRUE)
#Placement.Scores <-
#  group_by(acm_df_with_placements, Team.Placement) %>%
#  summarize(gender.ratio = sum(Gender == "Male")/sum(Gender == "Female"),
#            age.var = var(Age)) %>%
#  mutate(gender.ratio.dev = abs(gender.ratio - gender.ratio.ideal)) %>%
#  ungroup() %>%
## 3 is some arbitrary score weight
#  summarize(gender.ratio.score = mean(gender.ratio.dev)*3,
#            avg.age.var = -mean(age.var))
## Also, negative scores are better, and the "-" in front of mean age variance means that
## higher average variance of team ages gets relatively more favorable scores.
## NSM's new method for calling commute times
# system.time({
#   filter(acm_commutes_long, id_dest %in% team_placements_df$id_dest) %>%
#     summarize(sum(dist))
# })
# NSM: even faster way to do the same thing, with the data.table package
dt_commutes <- data.table(acm_commutes_long)
dt_commutes[id_dest %in% team_placements_df$id_dest,
sum(dist)]
## Old commute calc method references functions defined just before 'calculate_score'
# acm_df_with_placements$"Commute.Time" <- unlist(with(acm_df_with_placements, mapply(PickTime, id, Team.Placement)))
# return(sum(acm_df_with_placements$"Commute.Time"))
# Old commute calc method (10x slower!)
#   acm_row <- subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_row))]
#   acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
#   Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
#   acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
## USEFULL: system.time({ <<code to time>> })
# system.time({
output <- run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 1000, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
# Chris
## Chris: We want the following characteristics to be represented evenly across teams. We calculate ratios  for the # entire corps, and later calculate how well each team matches these ratios.
gender.ratio.ideal <- with(acm_df, sum(Gender == "Male")/sum(Gender == "Female"))
# age
# ethnicity
# attend local school, CY or local
# roommates? not necessary?
# Alex
# educational attainment (potentially different goals for HS/ES)
# tutoring experience (look at notes from survey)
# tutoring preference
# grade level preference
# language speaking
PickTime <- function(myid, myplace){subset(acm_commutes,
subset = id == myid,
select = myplace+1)}
## Characteristics that we don't want to be even across all schools
# edu.attainment.hs.ideal <-
# edu.attainment.es.ideal <-
# spanish
# Commute times in long format will be easier to index and subset
acm_commutes_long <-
select(acm_commutes, -or) %>%
gather(dest, dist, -id) %>%
mutate(id_dest = paste(id, dest, sep = "_"))
calculate_score = function(acm_df, team_placements) {
# Convert the team_placement list into a dataframe with an 'id' column
team_placements_df <- data.frame(id = 1:length(team_placements),
Team.Placement = team_placements,
dest = colnames(acm_commutes)[team_placements + 1]) %>%
within(id_dest <- paste(id, dest, sep = "_"))
# Merge team_placements_df with acm_df on the 'id' column we just created
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
# Merge acm_df_with_placements with school_df to pull in school characteristics
acm_df_with_placements <- merge(acm_df_with_placements, school_df, by.x = "Team.Placement", by.y = "id", all.x = TRUE)
#Placement.Scores <-
#  group_by(acm_df_with_placements, Team.Placement) %>%
#  summarize(gender.ratio = sum(Gender == "Male")/sum(Gender == "Female"),
#            age.var = var(Age)) %>%
#  mutate(gender.ratio.dev = abs(gender.ratio - gender.ratio.ideal)) %>%
#  ungroup() %>%
## 3 is some arbitrary score weight
#  summarize(gender.ratio.score = mean(gender.ratio.dev)*3,
#            avg.age.var = -mean(age.var))
## Also, negative scores are better, and the "-" in front of mean age variance means that
## higher average variance of team ages gets relatively more favorable scores.
## NSM's new method for calling commute times
# system.time({
#   filter(acm_commutes_long, id_dest %in% team_placements_df$id_dest) %>%
#     summarize(sum(dist))
# })
# # NSM: even faster way to do the same thing, with the data.table package
#
# dt_commutes <- data.table(acm_commutes_long)
#
# dt_commutes[id_dest %in% team_placements_df$id_dest,  sum(dist)]
## Old commute calc method references functions defined just before 'calculate_score'
acm_df_with_placements$"Commute.Time" <- unlist(with(acm_df_with_placements, mapply(PickTime, id, Team.Placement)))
return(sum(acm_df_with_placements$"Commute.Time"))
# Old commute calc method (10x slower!)
#   acm_row <- subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_row))]
#   acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
#   Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
#   acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
## USEFULL: system.time({ <<code to time>> })
# system.time({
output <- run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 1000, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
# Chris
## Chris: We want the following characteristics to be represented evenly across teams. We calculate ratios  for the # entire corps, and later calculate how well each team matches these ratios.
gender.ratio.ideal <- with(acm_df, sum(Gender == "Male")/sum(Gender == "Female"))
# age
# ethnicity
# attend local school, CY or local
# roommates? not necessary?
# Alex
# educational attainment (potentially different goals for HS/ES)
# tutoring experience (look at notes from survey)
# tutoring preference
# grade level preference
# language speaking
PickTime <- function(myid, myplace){subset(acm_commutes,
subset = id == myid,
select = myplace+1)}
## Characteristics that we don't want to be even across all schools
# edu.attainment.hs.ideal <-
# edu.attainment.es.ideal <-
# spanish
# Commute times in long format will be easier to index and subset
acm_commutes_long <-
select(acm_commutes, -or) %>%
gather(dest, dist, -id) %>%
mutate(id_dest = paste(id, dest, sep = "_"))
calculate_score = function(acm_df, team_placements) {
# Convert the team_placement list into a dataframe with an 'id' column
team_placements_df <- data.frame(id = 1:length(team_placements),
Team.Placement = team_placements)
## New! Convert the team_placement list into a dataframe with an 'id' column
# team_placements_df <- data.frame(id = 1:length(team_placements),
#                                  Team.Placement = team_placements,
#                                  dest = colnames(acm_commutes)[team_placements + 1]) %>%
#   within(id_dest <- paste(id, dest, sep = "_"))
# Merge team_placements_df with acm_df on the 'id' column we just created
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
# Merge acm_df_with_placements with school_df to pull in school characteristics
acm_df_with_placements <- merge(acm_df_with_placements, school_df, by.x = "Team.Placement", by.y = "id", all.x = TRUE)
#Placement.Scores <-
#  group_by(acm_df_with_placements, Team.Placement) %>%
#  summarize(gender.ratio = sum(Gender == "Male")/sum(Gender == "Female"),
#            age.var = var(Age)) %>%
#  mutate(gender.ratio.dev = abs(gender.ratio - gender.ratio.ideal)) %>%
#  ungroup() %>%
## 3 is some arbitrary score weight
#  summarize(gender.ratio.score = mean(gender.ratio.dev)*3,
#            avg.age.var = -mean(age.var))
## Also, negative scores are better, and the "-" in front of mean age variance means that
## higher average variance of team ages gets relatively more favorable scores.
## NSM's new method for calling commute times
# system.time({
#   filter(acm_commutes_long, id_dest %in% team_placements_df$id_dest) %>%
#     summarize(sum(dist))
# })
# # NSM: even faster way to do the same thing, with the data.table package
#
# dt_commutes <- data.table(acm_commutes_long)
#
# dt_commutes[id_dest %in% team_placements_df$id_dest,  sum(dist)]
## Old commute calc method references functions defined just before 'calculate_score'
acm_df_with_placements$"Commute.Time" <- unlist(with(acm_df_with_placements, mapply(PickTime, id, Team.Placement)))
return(sum(acm_df_with_placements$"Commute.Time"))
# Old commute calc method (10x slower!)
#   acm_row <- subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_row))]
#   acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
#   Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
#   acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
## USEFULL: system.time({ <<code to time>> })
# system.time({
output <- run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 1000, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
run_intermediate_annealing_process = function(acm_df, team_placements, placement_score, best_placements, best_score, starting_iteration, number_of_iterations, s_curve_amplitude, s_curve_center, s_curve_width) {
for(i in 1:number_of_iterations) {
iter = starting_iteration + i
temp = current_temperature(iter, s_curve_amplitude, s_curve_center, s_curve_width)
# Create a copy of team_placements
candidate_placements = team_placements
# Create an 'index' column
candidate_placements_df = data.frame(index=1:length(candidate_placements), candidate_placements)
# Choose 2 schools at random
schools_to_swap = sample(1:nrow(school_df), 2)
# Choose 1 ACM from each of those schools
swap1 = with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[1]], 1))
swap2 = with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[2]], 1))
# Swap the team assignment of those 2 ACMs
candidate_placements = replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
# Merge in ACM data
candidate_score = calculate_score(acm_df, candidate_placements)
browser()
if (temp > 0) {
ratio = exp((placement_score - candidate_score) / temp)
} else {
ratio = as.numeric(candidate_score < placement_score)
}
if (runif(1) < ratio) {
team_placements = candidate_placements
placement_score = candidate_score
if (placement_score < best_score) {
best_placements = team_placements
best_score = placement_score
}
}
}
return(list(team_placements=team_placements, placement_score=placement_score, best_placements=best_placements, best_score=best_score))
}
## USEFULL: system.time({ <<code to time>> })
# system.time({
output <- run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 1000, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
run_intermediate_annealing_process = function(acm_df, team_placements, placement_score, best_placements, best_score, starting_iteration, number_of_iterations, s_curve_amplitude, s_curve_center, s_curve_width) {
for(i in 1:number_of_iterations) {
iter = starting_iteration + i
temp = current_temperature(iter, s_curve_amplitude, s_curve_center, s_curve_width)
# Create a copy of team_placements
candidate_placements = team_placements
# Create an 'index' column
candidate_placements_df = data.frame(index=1:length(candidate_placements), candidate_placements)
# Choose 2 schools at random
schools_to_swap = sample(1:nrow(school_df), 2)
browser()
# Choose 1 ACM from each of those schools
swap1 = with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[1]], 1))
swap2 = with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[2]], 1))
# Swap the team assignment of those 2 ACMs
candidate_placements = replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
# Merge in ACM data
candidate_score = calculate_score(acm_df, candidate_placements)
if (temp > 0) {
ratio = exp((placement_score - candidate_score) / temp)
} else {
ratio = as.numeric(candidate_score < placement_score)
}
if (runif(1) < ratio) {
team_placements = candidate_placements
placement_score = candidate_score
if (placement_score < best_score) {
best_placements = team_placements
best_score = placement_score
}
}
}
return(list(team_placements=team_placements, placement_score=placement_score, best_placements=best_placements, best_score=best_score))
}
## USEFULL: system.time({ <<code to time>> })
# system.time({
output <- run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 1000, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
#})
output
run_intermediate_annealing_process = function(acm_df, team_placements, placement_score, best_placements, best_score, starting_iteration, number_of_iterations, s_curve_amplitude, s_curve_center, s_curve_width) {
for(i in 1:number_of_iterations) {
iter = starting_iteration + i
temp = current_temperature(iter, s_curve_amplitude, s_curve_center, s_curve_width)
# Create a copy of team_placements
candidate_placements = team_placements
# Create an 'index' column
candidate_placements_df = data.frame(index=1:length(candidate_placements), candidate_placements)
# Choose 2 schools at random
schools_to_swap = sample(1:nrow(school_df), 2)
# Choose 1 ACM from each of those schools
swap1 = with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[1]], 1))
swap2 = with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[2]], 1))
browser()
# Swap the team assignment of those 2 ACMs
candidate_placements = replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
# Merge in ACM data
candidate_score = calculate_score(acm_df, candidate_placements)
if (temp > 0) {
ratio = exp((placement_score - candidate_score) / temp)
} else {
ratio = as.numeric(candidate_score < placement_score)
}
if (runif(1) < ratio) {
team_placements = candidate_placements
placement_score = candidate_score
if (placement_score < best_score) {
best_placements = team_placements
best_score = placement_score
}
}
}
return(list(team_placements=team_placements, placement_score=placement_score, best_placements=best_placements, best_score=best_score))
}
## USEFULL: system.time({ <<code to time>> })
# system.time({
output <- run_intermediate_annealing_process(acm_df, team_placements, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 1000, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
swap1
swap2
swap2
schools_to_swap
with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[1]], 1))
with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[1]], 1))
with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[1]], 1))
with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[1]], 1))
sample(index[candidate_placements == schools_to_swap[1]], 1)
candidate_placements_df
length(candidate_placements)
team_placements
length(team_placements)
retunr(team_placements)
return(team_placements)
team_placements
team_placements <- as.list(team_placements)
team_placements
team_placement
team_placement <- initial_placement()
team_placements <- initial_placement()
team_placements
team_placements <- initial_placement()
team_placements$id <- nrow(team_placements)
team_placements
team_placements$id <- 1:nrow(team_placements)
team_placements
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
initial_placement <- function(){
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_df)){
team_slots = list(
# create a list that repeats each school 'id' for the size of each team
rep(x,
subset(school_df$"Team Size", school_df$"id" == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- data.frame(placement=unlist(team_placements))
# Randomize Starting Place
data.frame(placement=team_placements[sample(nrow(team_placements), replace=F), ],
id= 1:nrow(team_placements))
}
team_placements <- initial_placement()
team_placements
#team_placements_df <- data.frame(id = 1:length(team_placements),
#                                   Team.Placement = team_placements)
# Assumption: the number of ACMs in acm_df is exactly the same as the number of team slots
initial_placement <- function(){
# first create an empty list
team_placements = list()
# use a for-loop to read each team size
for (x in 1:nrow(school_df)){
team_slots = list(
# create a list that repeats each school 'id' for the size of each team
rep(x,
subset(school_df$"Team Size", school_df$"id" == x)
)
)
team_placements <- c(team_placements, team_slots)
}
team_placements <- data.frame(placement=unlist(team_placements))
# Randomize Starting Place
data.frame(placement=team_placements[sample(nrow(team_placements), replace=F), ],
id= 1:nrow(team_placements))
}
team_placements_df <- initial_placement()
# Chris
## Chris: We want the following characteristics to be represented evenly across teams. We calculate ratios  for the # entire corps, and later calculate how well each team matches these ratios.
gender.ratio.ideal <- with(acm_df, sum(Gender == "Male")/sum(Gender == "Female"))
# age
# ethnicity
# attend local school, CY or local
# roommates? not necessary?
# Alex
# educational attainment (potentially different goals for HS/ES)
# tutoring experience (look at notes from survey)
# tutoring preference
# grade level preference
# language speaking
PickTime <- function(myid, myplace){subset(acm_commutes,
subset = id == myid,
select = myplace+1)}
## Characteristics that we don't want to be even across all schools
# edu.attainment.hs.ideal <-
# edu.attainment.es.ideal <-
# spanish
# Commute times in long format will be easier to index and subset
acm_commutes_long <-
select(acm_commutes, -or) %>%
gather(dest, dist, -id) %>%
mutate(id_dest = paste(id, dest, sep = "_"))
calculate_score = function(acm_df, team_placements) {
## Convert the team_placement list into a dataframe with an 'id' column
# team_placements_df <- data.frame(id = 1:length(team_placements),
#                                 Team.Placement = team_placements)
## New! Convert the team_placement list into a dataframe with an 'id' column
# team_placements_df <- data.frame(id = 1:length(team_placements),
#                                  Team.Placement = team_placements,
#                                  dest = colnames(acm_commutes)[team_placements + 1]) %>%
#   within(id_dest <- paste(id, dest, sep = "_"))
# Merge team_placements_df with acm_df on the 'id' column we just created
acm_df_with_placements <- merge(acm_df, team_placements_df, by = "id", all.x = TRUE)
# Merge acm_df_with_placements with school_df to pull in school characteristics
acm_df_with_placements <- merge(acm_df_with_placements, school_df, by.x = "Team.Placement", by.y = "id", all.x = TRUE)
#Placement.Scores <-
#  group_by(acm_df_with_placements, Team.Placement) %>%
#  summarize(gender.ratio = sum(Gender == "Male")/sum(Gender == "Female"),
#            age.var = var(Age)) %>%
#  mutate(gender.ratio.dev = abs(gender.ratio - gender.ratio.ideal)) %>%
#  ungroup() %>%
## 3 is some arbitrary score weight
#  summarize(gender.ratio.score = mean(gender.ratio.dev)*3,
#            avg.age.var = -mean(age.var))
## Also, negative scores are better, and the "-" in front of mean age variance means that
## higher average variance of team ages gets relatively more favorable scores.
## NSM's new method for calling commute times
# system.time({
#   filter(acm_commutes_long, id_dest %in% team_placements_df$id_dest) %>%
#     summarize(sum(dist))
# })
# # NSM: even faster way to do the same thing, with the data.table package
#
# dt_commutes <- data.table(acm_commutes_long)
#
# dt_commutes[id_dest %in% team_placements_df$id_dest,  sum(dist)]
## Old commute calc method references functions defined just before 'calculate_score'
acm_df_with_placements$"Commute.Time" <- unlist(with(acm_df_with_placements, mapply(PickTime, id, Team.Placement)))
return(sum(acm_df_with_placements$"Commute.Time"))
# Old commute calc method (10x slower!)
#   acm_row <- subset(acm_df_with_placements, id == x)[ , grepl("Time.to.", names(acm_row))]
#   acm_commute <- acm_row[ , grepl("Time.to.", names(acm_row))]
#   Actual.Commute.Time <- acm_commute[acm_row$Team.Placement]
#   acm_commutes <- rbind(acm_commutes, Actual.Commute.Time[1,1])
}
run_intermediate_annealing_process = function(acm_df, team_placements_df, placement_score, best_placements, best_score, starting_iteration, number_of_iterations, s_curve_amplitude, s_curve_center, s_curve_width) {
for(i in 1:number_of_iterations) {
iter = starting_iteration + i
temp = current_temperature(iter, s_curve_amplitude, s_curve_center, s_curve_width)
# Create a copy of team_placements
candidate_placements = team_placements
# Create an 'index' column
candidate_placements_df = data.frame(index=1:length(candidate_placements), candidate_placements)
# Choose 2 schools at random
schools_to_swap = sample(1:nrow(school_df), 2)
# Choose 1 ACM from each of those schools
swap1 = with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[1]], 1))
swap2 = with(candidate_placements_df, sample(index[candidate_placements == schools_to_swap[2]], 1))
browser()
# Swap the team assignment of those 2 ACMs
candidate_placements = replace(candidate_placements, c(swap1, swap2), candidate_placements[c(swap2, swap1)])
# Merge in ACM data
candidate_score = calculate_score(acm_df, candidate_placements)
if (temp > 0) {
ratio = exp((placement_score - candidate_score) / temp)
} else {
ratio = as.numeric(candidate_score < placement_score)
}
if (runif(1) < ratio) {
team_placements = candidate_placements
placement_score = candidate_score
if (placement_score < best_score) {
best_placements = team_placements
best_score = placement_score
}
}
}
return(list(team_placements=team_placements, placement_score=placement_score, best_placements=best_placements, best_score=best_score))
}
## USEFULL: system.time({ <<code to time>> })
# system.time({
output <- run_intermediate_annealing_process(acm_df, team_placements_df, placement_score = 445109, best_placements = team_placements, best_score = 445109, starting_iteration = 1, number_of_iterations = 1000, s_curve_amplitude = 4000, s_curve_center = 0, s_curve_width = 3000)
## Chris: I made many assumptions in ratios between the levels of each factor, but they can easily be tweaked as the survey is developed, and this data will help us test the algorithm.
acm_df_fake <- data.frame(
First.Name = rep('', nrow(acm_df)),
Last.Name = rep('', nrow(acm_df)),
Address.Line.1 = rep('', nrow(acm_df)),
Address.Line.2 = rep('', nrow(acm_df)),
City = rep('', nrow(acm_df)),
State =  rep('', nrow(acm_df)),
Postal.Code = rep('', nrow(acm_df)),
Method.of.Commute = sample( c('driving', 'transit'), nrow(acm_df), replace=TRUE, prob=c(0.3, 0.7) ),
Gender = sample( c('Female',
'Male',
'Non-binary/third gender'), nrow(acm_df), replace=TRUE, prob=c(0.5, 0.4, 0.1) ),
Age = sample( c(18:24), nrow(acm_df), replace=TRUE, prob=c(0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1) ),
Language.Ability = sample( c('English Only',
'Some Spanish',
'Fluent Spanish'), nrow(acm_df), replace=TRUE,   prob=c(0.4, 0.4, 0.2) ),
Tutoring.Preference = sample( c('ELA',
'Math',
'Either/No Preference'), nrow(acm_df), replace=TRUE, prob=c(0.4, 0.4, 0.2) ),
Tutoring.Experience = sample( c('Yes', 'No'), nrow(acm_df), replace=TRUE, prob=c(0.7, 0.3) ),
Tutoring.Experience.Months = sample( c('0', '1-3', '4-6', '6-9', '9-12', 'more than 12'), nrow(acm_df),   replace=TRUE, prob=c(0.3, 0.2, 0.2, 0.1, 0.1, 0.1) ),
Tutoring.Experience.Grades = sample( c('none', '3rd-5th', '6th-8th', '9th-12th', 'other'), nrow(acm_df),   replace=TRUE, prob=c(0.3, 0.2, 0.2, 0.1, 0.1) ),
Teaching.Credential = sample( c('Yes', 'No'), nrow(acm_df), replace=TRUE, prob=c(0.1, 0.9) ),
Grade.Level.Preference = sample( c('3rd-5th',
'6th-8th',
'9th-12th'),
nrow(acm_df), replace=TRUE, prob=c(0.33,   0.33, 0.33) ),
Math.Attainment = sample( c('Pre-algebra or lower',
'Algebra I',
'Algebra II',
'Calculus or higher'),
nrow(acm_df), replace=TRUE, prob=c(0.25, 0.25, 0.25, 0.25) ),
Race.Ethnicity = sample( c('Hispanic or Latino or Spanish Origin of any race',
'American Indian or Alaskan   Native', 'Asian',
'Native Hawaiian or Other Pacific Islander',
'Black or African American',
'White'),
nrow(acm_df), replace=TRUE, prob=c(0.10, 0.03, 0.05, 0.04, 0.40, 0.38) ),
Educational.Attainment = sample( c('High School',
'Some College',
'College Degree'),
nrow(acm_df),   replace=TRUE, prob=c(0.2, 0.2, 0.6) ),
Roomates = rep('none', nrow(acm_df))
)
acm_df_fake
acm_enc
